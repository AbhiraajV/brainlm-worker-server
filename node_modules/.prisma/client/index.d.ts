
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Interpretation
 * 
 */
export type Interpretation = $Result.DefaultSelection<Prisma.$InterpretationPayload>
/**
 * Model Pattern
 * 
 */
export type Pattern = $Result.DefaultSelection<Prisma.$PatternPayload>
/**
 * Model PatternEvent
 * 
 */
export type PatternEvent = $Result.DefaultSelection<Prisma.$PatternEventPayload>
/**
 * Model Insight
 * 
 */
export type Insight = $Result.DefaultSelection<Prisma.$InsightPayload>
/**
 * Model InsightEvent
 * 
 */
export type InsightEvent = $Result.DefaultSelection<Prisma.$InsightEventPayload>
/**
 * Model InsightPattern
 * 
 */
export type InsightPattern = $Result.DefaultSelection<Prisma.$InsightPatternPayload>
/**
 * Model InsightInterpretation
 * 
 */
export type InsightInterpretation = $Result.DefaultSelection<Prisma.$InsightInterpretationPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InterpretationSource: {
  AUTOMATIC: 'AUTOMATIC',
  THERAPIST: 'THERAPIST',
  USER: 'USER'
};

export type InterpretationSource = (typeof InterpretationSource)[keyof typeof InterpretationSource]


export const PatternStatus: {
  ACTIVE: 'ACTIVE',
  SUPERSEDED: 'SUPERSEDED',
  DORMANT: 'DORMANT'
};

export type PatternStatus = (typeof PatternStatus)[keyof typeof PatternStatus]


export const InsightStatus: {
  CONFIRMED: 'CONFIRMED',
  LIKELY: 'LIKELY',
  SPECULATIVE: 'SPECULATIVE',
  SUPERSEDED: 'SUPERSEDED',
  WEAKENED: 'WEAKENED'
};

export type InsightStatus = (typeof InsightStatus)[keyof typeof InsightStatus]


export const ConfidenceLevel: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  EMERGING: 'EMERGING'
};

export type ConfidenceLevel = (typeof ConfidenceLevel)[keyof typeof ConfidenceLevel]


export const ReviewType: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type ReviewType = (typeof ReviewType)[keyof typeof ReviewType]


export const EvidenceRelevance: {
  PRIMARY: 'PRIMARY',
  SUPPORTING: 'SUPPORTING',
  CONTEXTUAL: 'CONTEXTUAL'
};

export type EvidenceRelevance = (typeof EvidenceRelevance)[keyof typeof EvidenceRelevance]

}

export type InterpretationSource = $Enums.InterpretationSource

export const InterpretationSource: typeof $Enums.InterpretationSource

export type PatternStatus = $Enums.PatternStatus

export const PatternStatus: typeof $Enums.PatternStatus

export type InsightStatus = $Enums.InsightStatus

export const InsightStatus: typeof $Enums.InsightStatus

export type ConfidenceLevel = $Enums.ConfidenceLevel

export const ConfidenceLevel: typeof $Enums.ConfidenceLevel

export type ReviewType = $Enums.ReviewType

export const ReviewType: typeof $Enums.ReviewType

export type EvidenceRelevance = $Enums.EvidenceRelevance

export const EvidenceRelevance: typeof $Enums.EvidenceRelevance

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interpretation`: Exposes CRUD operations for the **Interpretation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interpretations
    * const interpretations = await prisma.interpretation.findMany()
    * ```
    */
  get interpretation(): Prisma.InterpretationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pattern`: Exposes CRUD operations for the **Pattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patterns
    * const patterns = await prisma.pattern.findMany()
    * ```
    */
  get pattern(): Prisma.PatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patternEvent`: Exposes CRUD operations for the **PatternEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatternEvents
    * const patternEvents = await prisma.patternEvent.findMany()
    * ```
    */
  get patternEvent(): Prisma.PatternEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insight`: Exposes CRUD operations for the **Insight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insights
    * const insights = await prisma.insight.findMany()
    * ```
    */
  get insight(): Prisma.InsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insightEvent`: Exposes CRUD operations for the **InsightEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightEvents
    * const insightEvents = await prisma.insightEvent.findMany()
    * ```
    */
  get insightEvent(): Prisma.InsightEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insightPattern`: Exposes CRUD operations for the **InsightPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightPatterns
    * const insightPatterns = await prisma.insightPattern.findMany()
    * ```
    */
  get insightPattern(): Prisma.InsightPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insightInterpretation`: Exposes CRUD operations for the **InsightInterpretation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightInterpretations
    * const insightInterpretations = await prisma.insightInterpretation.findMany()
    * ```
    */
  get insightInterpretation(): Prisma.InsightInterpretationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Event: 'Event',
    Interpretation: 'Interpretation',
    Pattern: 'Pattern',
    PatternEvent: 'PatternEvent',
    Insight: 'Insight',
    InsightEvent: 'InsightEvent',
    InsightPattern: 'InsightPattern',
    InsightInterpretation: 'InsightInterpretation',
    Review: 'Review'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "event" | "interpretation" | "pattern" | "patternEvent" | "insight" | "insightEvent" | "insightPattern" | "insightInterpretation" | "review"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Interpretation: {
        payload: Prisma.$InterpretationPayload<ExtArgs>
        fields: Prisma.InterpretationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterpretationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterpretationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>
          }
          findFirst: {
            args: Prisma.InterpretationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterpretationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>
          }
          findMany: {
            args: Prisma.InterpretationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>[]
          }
          create: {
            args: Prisma.InterpretationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>
          }
          createMany: {
            args: Prisma.InterpretationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterpretationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>[]
          }
          delete: {
            args: Prisma.InterpretationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>
          }
          update: {
            args: Prisma.InterpretationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>
          }
          deleteMany: {
            args: Prisma.InterpretationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterpretationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterpretationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>[]
          }
          upsert: {
            args: Prisma.InterpretationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterpretationPayload>
          }
          aggregate: {
            args: Prisma.InterpretationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterpretation>
          }
          groupBy: {
            args: Prisma.InterpretationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterpretationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterpretationCountArgs<ExtArgs>
            result: $Utils.Optional<InterpretationCountAggregateOutputType> | number
          }
        }
      }
      Pattern: {
        payload: Prisma.$PatternPayload<ExtArgs>
        fields: Prisma.PatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          findFirst: {
            args: Prisma.PatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          findMany: {
            args: Prisma.PatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>[]
          }
          create: {
            args: Prisma.PatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          createMany: {
            args: Prisma.PatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>[]
          }
          delete: {
            args: Prisma.PatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          update: {
            args: Prisma.PatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          deleteMany: {
            args: Prisma.PatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>[]
          }
          upsert: {
            args: Prisma.PatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          aggregate: {
            args: Prisma.PatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePattern>
          }
          groupBy: {
            args: Prisma.PatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternCountArgs<ExtArgs>
            result: $Utils.Optional<PatternCountAggregateOutputType> | number
          }
        }
      }
      PatternEvent: {
        payload: Prisma.$PatternEventPayload<ExtArgs>
        fields: Prisma.PatternEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>
          }
          findFirst: {
            args: Prisma.PatternEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>
          }
          findMany: {
            args: Prisma.PatternEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>[]
          }
          create: {
            args: Prisma.PatternEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>
          }
          createMany: {
            args: Prisma.PatternEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>[]
          }
          delete: {
            args: Prisma.PatternEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>
          }
          update: {
            args: Prisma.PatternEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>
          }
          deleteMany: {
            args: Prisma.PatternEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatternEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>[]
          }
          upsert: {
            args: Prisma.PatternEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternEventPayload>
          }
          aggregate: {
            args: Prisma.PatternEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatternEvent>
          }
          groupBy: {
            args: Prisma.PatternEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternEventCountArgs<ExtArgs>
            result: $Utils.Optional<PatternEventCountAggregateOutputType> | number
          }
        }
      }
      Insight: {
        payload: Prisma.$InsightPayload<ExtArgs>
        fields: Prisma.InsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          findFirst: {
            args: Prisma.InsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          findMany: {
            args: Prisma.InsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          create: {
            args: Prisma.InsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          createMany: {
            args: Prisma.InsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          delete: {
            args: Prisma.InsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          update: {
            args: Prisma.InsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          deleteMany: {
            args: Prisma.InsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          upsert: {
            args: Prisma.InsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          aggregate: {
            args: Prisma.InsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsight>
          }
          groupBy: {
            args: Prisma.InsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightCountArgs<ExtArgs>
            result: $Utils.Optional<InsightCountAggregateOutputType> | number
          }
        }
      }
      InsightEvent: {
        payload: Prisma.$InsightEventPayload<ExtArgs>
        fields: Prisma.InsightEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>
          }
          findFirst: {
            args: Prisma.InsightEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>
          }
          findMany: {
            args: Prisma.InsightEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>[]
          }
          create: {
            args: Prisma.InsightEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>
          }
          createMany: {
            args: Prisma.InsightEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>[]
          }
          delete: {
            args: Prisma.InsightEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>
          }
          update: {
            args: Prisma.InsightEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>
          }
          deleteMany: {
            args: Prisma.InsightEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsightEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>[]
          }
          upsert: {
            args: Prisma.InsightEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightEventPayload>
          }
          aggregate: {
            args: Prisma.InsightEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightEvent>
          }
          groupBy: {
            args: Prisma.InsightEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightEventCountArgs<ExtArgs>
            result: $Utils.Optional<InsightEventCountAggregateOutputType> | number
          }
        }
      }
      InsightPattern: {
        payload: Prisma.$InsightPatternPayload<ExtArgs>
        fields: Prisma.InsightPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          findFirst: {
            args: Prisma.InsightPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          findMany: {
            args: Prisma.InsightPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>[]
          }
          create: {
            args: Prisma.InsightPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          createMany: {
            args: Prisma.InsightPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>[]
          }
          delete: {
            args: Prisma.InsightPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          update: {
            args: Prisma.InsightPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          deleteMany: {
            args: Prisma.InsightPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsightPatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>[]
          }
          upsert: {
            args: Prisma.InsightPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          aggregate: {
            args: Prisma.InsightPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightPattern>
          }
          groupBy: {
            args: Prisma.InsightPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightPatternCountArgs<ExtArgs>
            result: $Utils.Optional<InsightPatternCountAggregateOutputType> | number
          }
        }
      }
      InsightInterpretation: {
        payload: Prisma.$InsightInterpretationPayload<ExtArgs>
        fields: Prisma.InsightInterpretationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightInterpretationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightInterpretationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>
          }
          findFirst: {
            args: Prisma.InsightInterpretationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightInterpretationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>
          }
          findMany: {
            args: Prisma.InsightInterpretationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>[]
          }
          create: {
            args: Prisma.InsightInterpretationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>
          }
          createMany: {
            args: Prisma.InsightInterpretationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightInterpretationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>[]
          }
          delete: {
            args: Prisma.InsightInterpretationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>
          }
          update: {
            args: Prisma.InsightInterpretationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>
          }
          deleteMany: {
            args: Prisma.InsightInterpretationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightInterpretationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsightInterpretationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>[]
          }
          upsert: {
            args: Prisma.InsightInterpretationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightInterpretationPayload>
          }
          aggregate: {
            args: Prisma.InsightInterpretationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightInterpretation>
          }
          groupBy: {
            args: Prisma.InsightInterpretationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightInterpretationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightInterpretationCountArgs<ExtArgs>
            result: $Utils.Optional<InsightInterpretationCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    event?: EventOmit
    interpretation?: InterpretationOmit
    pattern?: PatternOmit
    patternEvent?: PatternEventOmit
    insight?: InsightOmit
    insightEvent?: InsightEventOmit
    insightPattern?: InsightPatternOmit
    insightInterpretation?: InsightInterpretationOmit
    review?: ReviewOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    events: number
    interpretations: number
    patterns: number
    insights: number
    reviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | UserCountOutputTypeCountEventsArgs
    interpretations?: boolean | UserCountOutputTypeCountInterpretationsArgs
    patterns?: boolean | UserCountOutputTypeCountPatternsArgs
    insights?: boolean | UserCountOutputTypeCountInsightsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterpretationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterpretationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    patternEvents: number
    insightEvents: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patternEvents?: boolean | EventCountOutputTypeCountPatternEventsArgs
    insightEvents?: boolean | EventCountOutputTypeCountInsightEventsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountPatternEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternEventWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountInsightEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightEventWhereInput
  }


  /**
   * Count Type InterpretationCountOutputType
   */

  export type InterpretationCountOutputType = {
    insightInterpretations: number
  }

  export type InterpretationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insightInterpretations?: boolean | InterpretationCountOutputTypeCountInsightInterpretationsArgs
  }

  // Custom InputTypes
  /**
   * InterpretationCountOutputType without action
   */
  export type InterpretationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterpretationCountOutputType
     */
    select?: InterpretationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterpretationCountOutputType without action
   */
  export type InterpretationCountOutputTypeCountInsightInterpretationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightInterpretationWhereInput
  }


  /**
   * Count Type PatternCountOutputType
   */

  export type PatternCountOutputType = {
    patternEvents: number
    insightPatterns: number
  }

  export type PatternCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patternEvents?: boolean | PatternCountOutputTypeCountPatternEventsArgs
    insightPatterns?: boolean | PatternCountOutputTypeCountInsightPatternsArgs
  }

  // Custom InputTypes
  /**
   * PatternCountOutputType without action
   */
  export type PatternCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternCountOutputType
     */
    select?: PatternCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatternCountOutputType without action
   */
  export type PatternCountOutputTypeCountPatternEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternEventWhereInput
  }

  /**
   * PatternCountOutputType without action
   */
  export type PatternCountOutputTypeCountInsightPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightPatternWhereInput
  }


  /**
   * Count Type InsightCountOutputType
   */

  export type InsightCountOutputType = {
    insightEvents: number
    insightPatterns: number
    insightInterpretations: number
  }

  export type InsightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insightEvents?: boolean | InsightCountOutputTypeCountInsightEventsArgs
    insightPatterns?: boolean | InsightCountOutputTypeCountInsightPatternsArgs
    insightInterpretations?: boolean | InsightCountOutputTypeCountInsightInterpretationsArgs
  }

  // Custom InputTypes
  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightCountOutputType
     */
    select?: InsightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeCountInsightEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightEventWhereInput
  }

  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeCountInsightPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightPatternWhereInput
  }

  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeCountInsightInterpretationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightInterpretationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    timezone: string | null
    baseline: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    timezone: string | null
    baseline: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    timezone: number
    baseline: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    timezone?: true
    baseline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    timezone?: true
    baseline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    timezone?: true
    baseline?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    timezone: string
    baseline: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    timezone?: boolean
    baseline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    events?: boolean | User$eventsArgs<ExtArgs>
    interpretations?: boolean | User$interpretationsArgs<ExtArgs>
    patterns?: boolean | User$patternsArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    timezone?: boolean
    baseline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    timezone?: boolean
    baseline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    timezone?: boolean
    baseline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "timezone" | "baseline" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | User$eventsArgs<ExtArgs>
    interpretations?: boolean | User$interpretationsArgs<ExtArgs>
    patterns?: boolean | User$patternsArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      events: Prisma.$EventPayload<ExtArgs>[]
      interpretations: Prisma.$InterpretationPayload<ExtArgs>[]
      patterns: Prisma.$PatternPayload<ExtArgs>[]
      insights: Prisma.$InsightPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      timezone: string
      baseline: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends User$eventsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interpretations<T extends User$interpretationsArgs<ExtArgs> = {}>(args?: Subset<T, User$interpretationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patterns<T extends User$patternsArgs<ExtArgs> = {}>(args?: Subset<T, User$patternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insights<T extends User$insightsArgs<ExtArgs> = {}>(args?: Subset<T, User$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly baseline: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.events
   */
  export type User$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.interpretations
   */
  export type User$interpretationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    where?: InterpretationWhereInput
    orderBy?: InterpretationOrderByWithRelationInput | InterpretationOrderByWithRelationInput[]
    cursor?: InterpretationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterpretationScalarFieldEnum | InterpretationScalarFieldEnum[]
  }

  /**
   * User.patterns
   */
  export type User$patternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    where?: PatternWhereInput
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    cursor?: PatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternScalarFieldEnum | PatternScalarFieldEnum[]
  }

  /**
   * User.insights
   */
  export type User$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    where?: InsightWhereInput
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    cursor?: InsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    audioRef: string | null
    occurredAt: Date | null
    createdAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    audioRef: string | null
    occurredAt: Date | null
    createdAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    audioRef: number
    occurredAt: number
    createdAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    audioRef?: true
    occurredAt?: true
    createdAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    audioRef?: true
    occurredAt?: true
    createdAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    audioRef?: true
    occurredAt?: true
    createdAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    userId: string
    content: string
    audioRef: string | null
    occurredAt: Date
    createdAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    audioRef?: boolean
    occurredAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    interpretation?: boolean | Event$interpretationArgs<ExtArgs>
    patternEvents?: boolean | Event$patternEventsArgs<ExtArgs>
    insightEvents?: boolean | Event$insightEventsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    audioRef?: boolean
    occurredAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    audioRef?: boolean
    occurredAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    audioRef?: boolean
    occurredAt?: boolean
    createdAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "audioRef" | "occurredAt" | "createdAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    interpretation?: boolean | Event$interpretationArgs<ExtArgs>
    patternEvents?: boolean | Event$patternEventsArgs<ExtArgs>
    insightEvents?: boolean | Event$insightEventsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      interpretation: Prisma.$InterpretationPayload<ExtArgs> | null
      patternEvents: Prisma.$PatternEventPayload<ExtArgs>[]
      insightEvents: Prisma.$InsightEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string
      audioRef: string | null
      occurredAt: Date
      createdAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interpretation<T extends Event$interpretationArgs<ExtArgs> = {}>(args?: Subset<T, Event$interpretationArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patternEvents<T extends Event$patternEventsArgs<ExtArgs> = {}>(args?: Subset<T, Event$patternEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insightEvents<T extends Event$insightEventsArgs<ExtArgs> = {}>(args?: Subset<T, Event$insightEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly userId: FieldRef<"Event", 'String'>
    readonly content: FieldRef<"Event", 'String'>
    readonly audioRef: FieldRef<"Event", 'String'>
    readonly occurredAt: FieldRef<"Event", 'DateTime'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.interpretation
   */
  export type Event$interpretationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    where?: InterpretationWhereInput
  }

  /**
   * Event.patternEvents
   */
  export type Event$patternEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    where?: PatternEventWhereInput
    orderBy?: PatternEventOrderByWithRelationInput | PatternEventOrderByWithRelationInput[]
    cursor?: PatternEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternEventScalarFieldEnum | PatternEventScalarFieldEnum[]
  }

  /**
   * Event.insightEvents
   */
  export type Event$insightEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    where?: InsightEventWhereInput
    orderBy?: InsightEventOrderByWithRelationInput | InsightEventOrderByWithRelationInput[]
    cursor?: InsightEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightEventScalarFieldEnum | InsightEventScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Interpretation
   */

  export type AggregateInterpretation = {
    _count: InterpretationCountAggregateOutputType | null
    _min: InterpretationMinAggregateOutputType | null
    _max: InterpretationMaxAggregateOutputType | null
  }

  export type InterpretationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventId: string | null
    content: string | null
    source: $Enums.InterpretationSource | null
    createdAt: Date | null
  }

  export type InterpretationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventId: string | null
    content: string | null
    source: $Enums.InterpretationSource | null
    createdAt: Date | null
  }

  export type InterpretationCountAggregateOutputType = {
    id: number
    userId: number
    eventId: number
    content: number
    source: number
    createdAt: number
    _all: number
  }


  export type InterpretationMinAggregateInputType = {
    id?: true
    userId?: true
    eventId?: true
    content?: true
    source?: true
    createdAt?: true
  }

  export type InterpretationMaxAggregateInputType = {
    id?: true
    userId?: true
    eventId?: true
    content?: true
    source?: true
    createdAt?: true
  }

  export type InterpretationCountAggregateInputType = {
    id?: true
    userId?: true
    eventId?: true
    content?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type InterpretationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interpretation to aggregate.
     */
    where?: InterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interpretations to fetch.
     */
    orderBy?: InterpretationOrderByWithRelationInput | InterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interpretations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interpretations
    **/
    _count?: true | InterpretationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterpretationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterpretationMaxAggregateInputType
  }

  export type GetInterpretationAggregateType<T extends InterpretationAggregateArgs> = {
        [P in keyof T & keyof AggregateInterpretation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterpretation[P]>
      : GetScalarType<T[P], AggregateInterpretation[P]>
  }




  export type InterpretationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterpretationWhereInput
    orderBy?: InterpretationOrderByWithAggregationInput | InterpretationOrderByWithAggregationInput[]
    by: InterpretationScalarFieldEnum[] | InterpretationScalarFieldEnum
    having?: InterpretationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterpretationCountAggregateInputType | true
    _min?: InterpretationMinAggregateInputType
    _max?: InterpretationMaxAggregateInputType
  }

  export type InterpretationGroupByOutputType = {
    id: string
    userId: string
    eventId: string
    content: string
    source: $Enums.InterpretationSource
    createdAt: Date
    _count: InterpretationCountAggregateOutputType | null
    _min: InterpretationMinAggregateOutputType | null
    _max: InterpretationMaxAggregateOutputType | null
  }

  type GetInterpretationGroupByPayload<T extends InterpretationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterpretationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterpretationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterpretationGroupByOutputType[P]>
            : GetScalarType<T[P], InterpretationGroupByOutputType[P]>
        }
      >
    >


  export type InterpretationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventId?: boolean
    content?: boolean
    source?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    insightInterpretations?: boolean | Interpretation$insightInterpretationsArgs<ExtArgs>
    _count?: boolean | InterpretationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interpretation"]>

  export type InterpretationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventId?: boolean
    content?: boolean
    source?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interpretation"]>

  export type InterpretationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventId?: boolean
    content?: boolean
    source?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interpretation"]>

  export type InterpretationSelectScalar = {
    id?: boolean
    userId?: boolean
    eventId?: boolean
    content?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type InterpretationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventId" | "content" | "source" | "createdAt", ExtArgs["result"]["interpretation"]>
  export type InterpretationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    insightInterpretations?: boolean | Interpretation$insightInterpretationsArgs<ExtArgs>
    _count?: boolean | InterpretationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterpretationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type InterpretationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $InterpretationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interpretation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
      insightInterpretations: Prisma.$InsightInterpretationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      eventId: string
      content: string
      source: $Enums.InterpretationSource
      createdAt: Date
    }, ExtArgs["result"]["interpretation"]>
    composites: {}
  }

  type InterpretationGetPayload<S extends boolean | null | undefined | InterpretationDefaultArgs> = $Result.GetResult<Prisma.$InterpretationPayload, S>

  type InterpretationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterpretationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterpretationCountAggregateInputType | true
    }

  export interface InterpretationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interpretation'], meta: { name: 'Interpretation' } }
    /**
     * Find zero or one Interpretation that matches the filter.
     * @param {InterpretationFindUniqueArgs} args - Arguments to find a Interpretation
     * @example
     * // Get one Interpretation
     * const interpretation = await prisma.interpretation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterpretationFindUniqueArgs>(args: SelectSubset<T, InterpretationFindUniqueArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interpretation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterpretationFindUniqueOrThrowArgs} args - Arguments to find a Interpretation
     * @example
     * // Get one Interpretation
     * const interpretation = await prisma.interpretation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterpretationFindUniqueOrThrowArgs>(args: SelectSubset<T, InterpretationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interpretation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterpretationFindFirstArgs} args - Arguments to find a Interpretation
     * @example
     * // Get one Interpretation
     * const interpretation = await prisma.interpretation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterpretationFindFirstArgs>(args?: SelectSubset<T, InterpretationFindFirstArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interpretation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterpretationFindFirstOrThrowArgs} args - Arguments to find a Interpretation
     * @example
     * // Get one Interpretation
     * const interpretation = await prisma.interpretation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterpretationFindFirstOrThrowArgs>(args?: SelectSubset<T, InterpretationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interpretations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterpretationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interpretations
     * const interpretations = await prisma.interpretation.findMany()
     * 
     * // Get first 10 Interpretations
     * const interpretations = await prisma.interpretation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interpretationWithIdOnly = await prisma.interpretation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterpretationFindManyArgs>(args?: SelectSubset<T, InterpretationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interpretation.
     * @param {InterpretationCreateArgs} args - Arguments to create a Interpretation.
     * @example
     * // Create one Interpretation
     * const Interpretation = await prisma.interpretation.create({
     *   data: {
     *     // ... data to create a Interpretation
     *   }
     * })
     * 
     */
    create<T extends InterpretationCreateArgs>(args: SelectSubset<T, InterpretationCreateArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interpretations.
     * @param {InterpretationCreateManyArgs} args - Arguments to create many Interpretations.
     * @example
     * // Create many Interpretations
     * const interpretation = await prisma.interpretation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterpretationCreateManyArgs>(args?: SelectSubset<T, InterpretationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interpretations and returns the data saved in the database.
     * @param {InterpretationCreateManyAndReturnArgs} args - Arguments to create many Interpretations.
     * @example
     * // Create many Interpretations
     * const interpretation = await prisma.interpretation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interpretations and only return the `id`
     * const interpretationWithIdOnly = await prisma.interpretation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterpretationCreateManyAndReturnArgs>(args?: SelectSubset<T, InterpretationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interpretation.
     * @param {InterpretationDeleteArgs} args - Arguments to delete one Interpretation.
     * @example
     * // Delete one Interpretation
     * const Interpretation = await prisma.interpretation.delete({
     *   where: {
     *     // ... filter to delete one Interpretation
     *   }
     * })
     * 
     */
    delete<T extends InterpretationDeleteArgs>(args: SelectSubset<T, InterpretationDeleteArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interpretation.
     * @param {InterpretationUpdateArgs} args - Arguments to update one Interpretation.
     * @example
     * // Update one Interpretation
     * const interpretation = await prisma.interpretation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterpretationUpdateArgs>(args: SelectSubset<T, InterpretationUpdateArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interpretations.
     * @param {InterpretationDeleteManyArgs} args - Arguments to filter Interpretations to delete.
     * @example
     * // Delete a few Interpretations
     * const { count } = await prisma.interpretation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterpretationDeleteManyArgs>(args?: SelectSubset<T, InterpretationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interpretations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterpretationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interpretations
     * const interpretation = await prisma.interpretation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterpretationUpdateManyArgs>(args: SelectSubset<T, InterpretationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interpretations and returns the data updated in the database.
     * @param {InterpretationUpdateManyAndReturnArgs} args - Arguments to update many Interpretations.
     * @example
     * // Update many Interpretations
     * const interpretation = await prisma.interpretation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interpretations and only return the `id`
     * const interpretationWithIdOnly = await prisma.interpretation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterpretationUpdateManyAndReturnArgs>(args: SelectSubset<T, InterpretationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interpretation.
     * @param {InterpretationUpsertArgs} args - Arguments to update or create a Interpretation.
     * @example
     * // Update or create a Interpretation
     * const interpretation = await prisma.interpretation.upsert({
     *   create: {
     *     // ... data to create a Interpretation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interpretation we want to update
     *   }
     * })
     */
    upsert<T extends InterpretationUpsertArgs>(args: SelectSubset<T, InterpretationUpsertArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interpretations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterpretationCountArgs} args - Arguments to filter Interpretations to count.
     * @example
     * // Count the number of Interpretations
     * const count = await prisma.interpretation.count({
     *   where: {
     *     // ... the filter for the Interpretations we want to count
     *   }
     * })
    **/
    count<T extends InterpretationCountArgs>(
      args?: Subset<T, InterpretationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterpretationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interpretation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterpretationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterpretationAggregateArgs>(args: Subset<T, InterpretationAggregateArgs>): Prisma.PrismaPromise<GetInterpretationAggregateType<T>>

    /**
     * Group by Interpretation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterpretationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterpretationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterpretationGroupByArgs['orderBy'] }
        : { orderBy?: InterpretationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterpretationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterpretationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interpretation model
   */
  readonly fields: InterpretationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interpretation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterpretationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    insightInterpretations<T extends Interpretation$insightInterpretationsArgs<ExtArgs> = {}>(args?: Subset<T, Interpretation$insightInterpretationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interpretation model
   */
  interface InterpretationFieldRefs {
    readonly id: FieldRef<"Interpretation", 'String'>
    readonly userId: FieldRef<"Interpretation", 'String'>
    readonly eventId: FieldRef<"Interpretation", 'String'>
    readonly content: FieldRef<"Interpretation", 'String'>
    readonly source: FieldRef<"Interpretation", 'InterpretationSource'>
    readonly createdAt: FieldRef<"Interpretation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interpretation findUnique
   */
  export type InterpretationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * Filter, which Interpretation to fetch.
     */
    where: InterpretationWhereUniqueInput
  }

  /**
   * Interpretation findUniqueOrThrow
   */
  export type InterpretationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * Filter, which Interpretation to fetch.
     */
    where: InterpretationWhereUniqueInput
  }

  /**
   * Interpretation findFirst
   */
  export type InterpretationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * Filter, which Interpretation to fetch.
     */
    where?: InterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interpretations to fetch.
     */
    orderBy?: InterpretationOrderByWithRelationInput | InterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interpretations.
     */
    cursor?: InterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interpretations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interpretations.
     */
    distinct?: InterpretationScalarFieldEnum | InterpretationScalarFieldEnum[]
  }

  /**
   * Interpretation findFirstOrThrow
   */
  export type InterpretationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * Filter, which Interpretation to fetch.
     */
    where?: InterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interpretations to fetch.
     */
    orderBy?: InterpretationOrderByWithRelationInput | InterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interpretations.
     */
    cursor?: InterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interpretations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interpretations.
     */
    distinct?: InterpretationScalarFieldEnum | InterpretationScalarFieldEnum[]
  }

  /**
   * Interpretation findMany
   */
  export type InterpretationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * Filter, which Interpretations to fetch.
     */
    where?: InterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interpretations to fetch.
     */
    orderBy?: InterpretationOrderByWithRelationInput | InterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interpretations.
     */
    cursor?: InterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interpretations.
     */
    skip?: number
    distinct?: InterpretationScalarFieldEnum | InterpretationScalarFieldEnum[]
  }

  /**
   * Interpretation create
   */
  export type InterpretationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * The data needed to create a Interpretation.
     */
    data: XOR<InterpretationCreateInput, InterpretationUncheckedCreateInput>
  }

  /**
   * Interpretation createMany
   */
  export type InterpretationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interpretations.
     */
    data: InterpretationCreateManyInput | InterpretationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interpretation createManyAndReturn
   */
  export type InterpretationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * The data used to create many Interpretations.
     */
    data: InterpretationCreateManyInput | InterpretationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interpretation update
   */
  export type InterpretationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * The data needed to update a Interpretation.
     */
    data: XOR<InterpretationUpdateInput, InterpretationUncheckedUpdateInput>
    /**
     * Choose, which Interpretation to update.
     */
    where: InterpretationWhereUniqueInput
  }

  /**
   * Interpretation updateMany
   */
  export type InterpretationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interpretations.
     */
    data: XOR<InterpretationUpdateManyMutationInput, InterpretationUncheckedUpdateManyInput>
    /**
     * Filter which Interpretations to update
     */
    where?: InterpretationWhereInput
    /**
     * Limit how many Interpretations to update.
     */
    limit?: number
  }

  /**
   * Interpretation updateManyAndReturn
   */
  export type InterpretationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * The data used to update Interpretations.
     */
    data: XOR<InterpretationUpdateManyMutationInput, InterpretationUncheckedUpdateManyInput>
    /**
     * Filter which Interpretations to update
     */
    where?: InterpretationWhereInput
    /**
     * Limit how many Interpretations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interpretation upsert
   */
  export type InterpretationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * The filter to search for the Interpretation to update in case it exists.
     */
    where: InterpretationWhereUniqueInput
    /**
     * In case the Interpretation found by the `where` argument doesn't exist, create a new Interpretation with this data.
     */
    create: XOR<InterpretationCreateInput, InterpretationUncheckedCreateInput>
    /**
     * In case the Interpretation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterpretationUpdateInput, InterpretationUncheckedUpdateInput>
  }

  /**
   * Interpretation delete
   */
  export type InterpretationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
    /**
     * Filter which Interpretation to delete.
     */
    where: InterpretationWhereUniqueInput
  }

  /**
   * Interpretation deleteMany
   */
  export type InterpretationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interpretations to delete
     */
    where?: InterpretationWhereInput
    /**
     * Limit how many Interpretations to delete.
     */
    limit?: number
  }

  /**
   * Interpretation.insightInterpretations
   */
  export type Interpretation$insightInterpretationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    where?: InsightInterpretationWhereInput
    orderBy?: InsightInterpretationOrderByWithRelationInput | InsightInterpretationOrderByWithRelationInput[]
    cursor?: InsightInterpretationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightInterpretationScalarFieldEnum | InsightInterpretationScalarFieldEnum[]
  }

  /**
   * Interpretation without action
   */
  export type InterpretationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interpretation
     */
    select?: InterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interpretation
     */
    omit?: InterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterpretationInclude<ExtArgs> | null
  }


  /**
   * Model Pattern
   */

  export type AggregatePattern = {
    _count: PatternCountAggregateOutputType | null
    _min: PatternMinAggregateOutputType | null
    _max: PatternMaxAggregateOutputType | null
  }

  export type PatternMinAggregateOutputType = {
    id: string | null
    userId: string | null
    description: string | null
    firstDetectedAt: Date | null
    lastReinforcedAt: Date | null
    status: $Enums.PatternStatus | null
    createdAt: Date | null
  }

  export type PatternMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    description: string | null
    firstDetectedAt: Date | null
    lastReinforcedAt: Date | null
    status: $Enums.PatternStatus | null
    createdAt: Date | null
  }

  export type PatternCountAggregateOutputType = {
    id: number
    userId: number
    description: number
    firstDetectedAt: number
    lastReinforcedAt: number
    status: number
    createdAt: number
    _all: number
  }


  export type PatternMinAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    firstDetectedAt?: true
    lastReinforcedAt?: true
    status?: true
    createdAt?: true
  }

  export type PatternMaxAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    firstDetectedAt?: true
    lastReinforcedAt?: true
    status?: true
    createdAt?: true
  }

  export type PatternCountAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    firstDetectedAt?: true
    lastReinforcedAt?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type PatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pattern to aggregate.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patterns
    **/
    _count?: true | PatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatternMaxAggregateInputType
  }

  export type GetPatternAggregateType<T extends PatternAggregateArgs> = {
        [P in keyof T & keyof AggregatePattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePattern[P]>
      : GetScalarType<T[P], AggregatePattern[P]>
  }




  export type PatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternWhereInput
    orderBy?: PatternOrderByWithAggregationInput | PatternOrderByWithAggregationInput[]
    by: PatternScalarFieldEnum[] | PatternScalarFieldEnum
    having?: PatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternCountAggregateInputType | true
    _min?: PatternMinAggregateInputType
    _max?: PatternMaxAggregateInputType
  }

  export type PatternGroupByOutputType = {
    id: string
    userId: string
    description: string
    firstDetectedAt: Date
    lastReinforcedAt: Date
    status: $Enums.PatternStatus
    createdAt: Date
    _count: PatternCountAggregateOutputType | null
    _min: PatternMinAggregateOutputType | null
    _max: PatternMaxAggregateOutputType | null
  }

  type GetPatternGroupByPayload<T extends PatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternGroupByOutputType[P]>
            : GetScalarType<T[P], PatternGroupByOutputType[P]>
        }
      >
    >


  export type PatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    description?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    patternEvents?: boolean | Pattern$patternEventsArgs<ExtArgs>
    insightPatterns?: boolean | Pattern$insightPatternsArgs<ExtArgs>
    _count?: boolean | PatternCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pattern"]>

  export type PatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    description?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pattern"]>

  export type PatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    description?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pattern"]>

  export type PatternSelectScalar = {
    id?: boolean
    userId?: boolean
    description?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type PatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "description" | "firstDetectedAt" | "lastReinforcedAt" | "status" | "createdAt", ExtArgs["result"]["pattern"]>
  export type PatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    patternEvents?: boolean | Pattern$patternEventsArgs<ExtArgs>
    insightPatterns?: boolean | Pattern$insightPatternsArgs<ExtArgs>
    _count?: boolean | PatternCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pattern"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      patternEvents: Prisma.$PatternEventPayload<ExtArgs>[]
      insightPatterns: Prisma.$InsightPatternPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      description: string
      firstDetectedAt: Date
      lastReinforcedAt: Date
      status: $Enums.PatternStatus
      createdAt: Date
    }, ExtArgs["result"]["pattern"]>
    composites: {}
  }

  type PatternGetPayload<S extends boolean | null | undefined | PatternDefaultArgs> = $Result.GetResult<Prisma.$PatternPayload, S>

  type PatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatternCountAggregateInputType | true
    }

  export interface PatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pattern'], meta: { name: 'Pattern' } }
    /**
     * Find zero or one Pattern that matches the filter.
     * @param {PatternFindUniqueArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternFindUniqueArgs>(args: SelectSubset<T, PatternFindUniqueArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatternFindUniqueOrThrowArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternFindFirstArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternFindFirstArgs>(args?: SelectSubset<T, PatternFindFirstArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternFindFirstOrThrowArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patterns
     * const patterns = await prisma.pattern.findMany()
     * 
     * // Get first 10 Patterns
     * const patterns = await prisma.pattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patternWithIdOnly = await prisma.pattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatternFindManyArgs>(args?: SelectSubset<T, PatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pattern.
     * @param {PatternCreateArgs} args - Arguments to create a Pattern.
     * @example
     * // Create one Pattern
     * const Pattern = await prisma.pattern.create({
     *   data: {
     *     // ... data to create a Pattern
     *   }
     * })
     * 
     */
    create<T extends PatternCreateArgs>(args: SelectSubset<T, PatternCreateArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patterns.
     * @param {PatternCreateManyArgs} args - Arguments to create many Patterns.
     * @example
     * // Create many Patterns
     * const pattern = await prisma.pattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatternCreateManyArgs>(args?: SelectSubset<T, PatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patterns and returns the data saved in the database.
     * @param {PatternCreateManyAndReturnArgs} args - Arguments to create many Patterns.
     * @example
     * // Create many Patterns
     * const pattern = await prisma.pattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patterns and only return the `id`
     * const patternWithIdOnly = await prisma.pattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatternCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pattern.
     * @param {PatternDeleteArgs} args - Arguments to delete one Pattern.
     * @example
     * // Delete one Pattern
     * const Pattern = await prisma.pattern.delete({
     *   where: {
     *     // ... filter to delete one Pattern
     *   }
     * })
     * 
     */
    delete<T extends PatternDeleteArgs>(args: SelectSubset<T, PatternDeleteArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pattern.
     * @param {PatternUpdateArgs} args - Arguments to update one Pattern.
     * @example
     * // Update one Pattern
     * const pattern = await prisma.pattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatternUpdateArgs>(args: SelectSubset<T, PatternUpdateArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patterns.
     * @param {PatternDeleteManyArgs} args - Arguments to filter Patterns to delete.
     * @example
     * // Delete a few Patterns
     * const { count } = await prisma.pattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatternDeleteManyArgs>(args?: SelectSubset<T, PatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patterns
     * const pattern = await prisma.pattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatternUpdateManyArgs>(args: SelectSubset<T, PatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patterns and returns the data updated in the database.
     * @param {PatternUpdateManyAndReturnArgs} args - Arguments to update many Patterns.
     * @example
     * // Update many Patterns
     * const pattern = await prisma.pattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patterns and only return the `id`
     * const patternWithIdOnly = await prisma.pattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatternUpdateManyAndReturnArgs>(args: SelectSubset<T, PatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pattern.
     * @param {PatternUpsertArgs} args - Arguments to update or create a Pattern.
     * @example
     * // Update or create a Pattern
     * const pattern = await prisma.pattern.upsert({
     *   create: {
     *     // ... data to create a Pattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pattern we want to update
     *   }
     * })
     */
    upsert<T extends PatternUpsertArgs>(args: SelectSubset<T, PatternUpsertArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternCountArgs} args - Arguments to filter Patterns to count.
     * @example
     * // Count the number of Patterns
     * const count = await prisma.pattern.count({
     *   where: {
     *     // ... the filter for the Patterns we want to count
     *   }
     * })
    **/
    count<T extends PatternCountArgs>(
      args?: Subset<T, PatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternAggregateArgs>(args: Subset<T, PatternAggregateArgs>): Prisma.PrismaPromise<GetPatternAggregateType<T>>

    /**
     * Group by Pattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternGroupByArgs['orderBy'] }
        : { orderBy?: PatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pattern model
   */
  readonly fields: PatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patternEvents<T extends Pattern$patternEventsArgs<ExtArgs> = {}>(args?: Subset<T, Pattern$patternEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insightPatterns<T extends Pattern$insightPatternsArgs<ExtArgs> = {}>(args?: Subset<T, Pattern$insightPatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pattern model
   */
  interface PatternFieldRefs {
    readonly id: FieldRef<"Pattern", 'String'>
    readonly userId: FieldRef<"Pattern", 'String'>
    readonly description: FieldRef<"Pattern", 'String'>
    readonly firstDetectedAt: FieldRef<"Pattern", 'DateTime'>
    readonly lastReinforcedAt: FieldRef<"Pattern", 'DateTime'>
    readonly status: FieldRef<"Pattern", 'PatternStatus'>
    readonly createdAt: FieldRef<"Pattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pattern findUnique
   */
  export type PatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern findUniqueOrThrow
   */
  export type PatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern findFirst
   */
  export type PatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patterns.
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patterns.
     */
    distinct?: PatternScalarFieldEnum | PatternScalarFieldEnum[]
  }

  /**
   * Pattern findFirstOrThrow
   */
  export type PatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patterns.
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patterns.
     */
    distinct?: PatternScalarFieldEnum | PatternScalarFieldEnum[]
  }

  /**
   * Pattern findMany
   */
  export type PatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Patterns to fetch.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patterns.
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    distinct?: PatternScalarFieldEnum | PatternScalarFieldEnum[]
  }

  /**
   * Pattern create
   */
  export type PatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * The data needed to create a Pattern.
     */
    data: XOR<PatternCreateInput, PatternUncheckedCreateInput>
  }

  /**
   * Pattern createMany
   */
  export type PatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patterns.
     */
    data: PatternCreateManyInput | PatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pattern createManyAndReturn
   */
  export type PatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * The data used to create many Patterns.
     */
    data: PatternCreateManyInput | PatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pattern update
   */
  export type PatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * The data needed to update a Pattern.
     */
    data: XOR<PatternUpdateInput, PatternUncheckedUpdateInput>
    /**
     * Choose, which Pattern to update.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern updateMany
   */
  export type PatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patterns.
     */
    data: XOR<PatternUpdateManyMutationInput, PatternUncheckedUpdateManyInput>
    /**
     * Filter which Patterns to update
     */
    where?: PatternWhereInput
    /**
     * Limit how many Patterns to update.
     */
    limit?: number
  }

  /**
   * Pattern updateManyAndReturn
   */
  export type PatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * The data used to update Patterns.
     */
    data: XOR<PatternUpdateManyMutationInput, PatternUncheckedUpdateManyInput>
    /**
     * Filter which Patterns to update
     */
    where?: PatternWhereInput
    /**
     * Limit how many Patterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pattern upsert
   */
  export type PatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * The filter to search for the Pattern to update in case it exists.
     */
    where: PatternWhereUniqueInput
    /**
     * In case the Pattern found by the `where` argument doesn't exist, create a new Pattern with this data.
     */
    create: XOR<PatternCreateInput, PatternUncheckedCreateInput>
    /**
     * In case the Pattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternUpdateInput, PatternUncheckedUpdateInput>
  }

  /**
   * Pattern delete
   */
  export type PatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter which Pattern to delete.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern deleteMany
   */
  export type PatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patterns to delete
     */
    where?: PatternWhereInput
    /**
     * Limit how many Patterns to delete.
     */
    limit?: number
  }

  /**
   * Pattern.patternEvents
   */
  export type Pattern$patternEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    where?: PatternEventWhereInput
    orderBy?: PatternEventOrderByWithRelationInput | PatternEventOrderByWithRelationInput[]
    cursor?: PatternEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternEventScalarFieldEnum | PatternEventScalarFieldEnum[]
  }

  /**
   * Pattern.insightPatterns
   */
  export type Pattern$insightPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    where?: InsightPatternWhereInput
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    cursor?: InsightPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * Pattern without action
   */
  export type PatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pattern
     */
    omit?: PatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
  }


  /**
   * Model PatternEvent
   */

  export type AggregatePatternEvent = {
    _count: PatternEventCountAggregateOutputType | null
    _min: PatternEventMinAggregateOutputType | null
    _max: PatternEventMaxAggregateOutputType | null
  }

  export type PatternEventMinAggregateOutputType = {
    id: string | null
    patternId: string | null
    eventId: string | null
    addedAt: Date | null
  }

  export type PatternEventMaxAggregateOutputType = {
    id: string | null
    patternId: string | null
    eventId: string | null
    addedAt: Date | null
  }

  export type PatternEventCountAggregateOutputType = {
    id: number
    patternId: number
    eventId: number
    addedAt: number
    _all: number
  }


  export type PatternEventMinAggregateInputType = {
    id?: true
    patternId?: true
    eventId?: true
    addedAt?: true
  }

  export type PatternEventMaxAggregateInputType = {
    id?: true
    patternId?: true
    eventId?: true
    addedAt?: true
  }

  export type PatternEventCountAggregateInputType = {
    id?: true
    patternId?: true
    eventId?: true
    addedAt?: true
    _all?: true
  }

  export type PatternEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternEvent to aggregate.
     */
    where?: PatternEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternEvents to fetch.
     */
    orderBy?: PatternEventOrderByWithRelationInput | PatternEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatternEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatternEvents
    **/
    _count?: true | PatternEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatternEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatternEventMaxAggregateInputType
  }

  export type GetPatternEventAggregateType<T extends PatternEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePatternEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatternEvent[P]>
      : GetScalarType<T[P], AggregatePatternEvent[P]>
  }




  export type PatternEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternEventWhereInput
    orderBy?: PatternEventOrderByWithAggregationInput | PatternEventOrderByWithAggregationInput[]
    by: PatternEventScalarFieldEnum[] | PatternEventScalarFieldEnum
    having?: PatternEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternEventCountAggregateInputType | true
    _min?: PatternEventMinAggregateInputType
    _max?: PatternEventMaxAggregateInputType
  }

  export type PatternEventGroupByOutputType = {
    id: string
    patternId: string
    eventId: string
    addedAt: Date
    _count: PatternEventCountAggregateOutputType | null
    _min: PatternEventMinAggregateOutputType | null
    _max: PatternEventMaxAggregateOutputType | null
  }

  type GetPatternEventGroupByPayload<T extends PatternEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternEventGroupByOutputType[P]>
            : GetScalarType<T[P], PatternEventGroupByOutputType[P]>
        }
      >
    >


  export type PatternEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    eventId?: boolean
    addedAt?: boolean
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternEvent"]>

  export type PatternEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    eventId?: boolean
    addedAt?: boolean
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternEvent"]>

  export type PatternEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    eventId?: boolean
    addedAt?: boolean
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternEvent"]>

  export type PatternEventSelectScalar = {
    id?: boolean
    patternId?: boolean
    eventId?: boolean
    addedAt?: boolean
  }

  export type PatternEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patternId" | "eventId" | "addedAt", ExtArgs["result"]["patternEvent"]>
  export type PatternEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type PatternEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type PatternEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $PatternEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatternEvent"
    objects: {
      pattern: Prisma.$PatternPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternId: string
      eventId: string
      addedAt: Date
    }, ExtArgs["result"]["patternEvent"]>
    composites: {}
  }

  type PatternEventGetPayload<S extends boolean | null | undefined | PatternEventDefaultArgs> = $Result.GetResult<Prisma.$PatternEventPayload, S>

  type PatternEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatternEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatternEventCountAggregateInputType | true
    }

  export interface PatternEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatternEvent'], meta: { name: 'PatternEvent' } }
    /**
     * Find zero or one PatternEvent that matches the filter.
     * @param {PatternEventFindUniqueArgs} args - Arguments to find a PatternEvent
     * @example
     * // Get one PatternEvent
     * const patternEvent = await prisma.patternEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternEventFindUniqueArgs>(args: SelectSubset<T, PatternEventFindUniqueArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatternEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatternEventFindUniqueOrThrowArgs} args - Arguments to find a PatternEvent
     * @example
     * // Get one PatternEvent
     * const patternEvent = await prisma.patternEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternEventFindFirstArgs} args - Arguments to find a PatternEvent
     * @example
     * // Get one PatternEvent
     * const patternEvent = await prisma.patternEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternEventFindFirstArgs>(args?: SelectSubset<T, PatternEventFindFirstArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternEventFindFirstOrThrowArgs} args - Arguments to find a PatternEvent
     * @example
     * // Get one PatternEvent
     * const patternEvent = await prisma.patternEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatternEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatternEvents
     * const patternEvents = await prisma.patternEvent.findMany()
     * 
     * // Get first 10 PatternEvents
     * const patternEvents = await prisma.patternEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patternEventWithIdOnly = await prisma.patternEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatternEventFindManyArgs>(args?: SelectSubset<T, PatternEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatternEvent.
     * @param {PatternEventCreateArgs} args - Arguments to create a PatternEvent.
     * @example
     * // Create one PatternEvent
     * const PatternEvent = await prisma.patternEvent.create({
     *   data: {
     *     // ... data to create a PatternEvent
     *   }
     * })
     * 
     */
    create<T extends PatternEventCreateArgs>(args: SelectSubset<T, PatternEventCreateArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatternEvents.
     * @param {PatternEventCreateManyArgs} args - Arguments to create many PatternEvents.
     * @example
     * // Create many PatternEvents
     * const patternEvent = await prisma.patternEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatternEventCreateManyArgs>(args?: SelectSubset<T, PatternEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatternEvents and returns the data saved in the database.
     * @param {PatternEventCreateManyAndReturnArgs} args - Arguments to create many PatternEvents.
     * @example
     * // Create many PatternEvents
     * const patternEvent = await prisma.patternEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatternEvents and only return the `id`
     * const patternEventWithIdOnly = await prisma.patternEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatternEventCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatternEvent.
     * @param {PatternEventDeleteArgs} args - Arguments to delete one PatternEvent.
     * @example
     * // Delete one PatternEvent
     * const PatternEvent = await prisma.patternEvent.delete({
     *   where: {
     *     // ... filter to delete one PatternEvent
     *   }
     * })
     * 
     */
    delete<T extends PatternEventDeleteArgs>(args: SelectSubset<T, PatternEventDeleteArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatternEvent.
     * @param {PatternEventUpdateArgs} args - Arguments to update one PatternEvent.
     * @example
     * // Update one PatternEvent
     * const patternEvent = await prisma.patternEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatternEventUpdateArgs>(args: SelectSubset<T, PatternEventUpdateArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatternEvents.
     * @param {PatternEventDeleteManyArgs} args - Arguments to filter PatternEvents to delete.
     * @example
     * // Delete a few PatternEvents
     * const { count } = await prisma.patternEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatternEventDeleteManyArgs>(args?: SelectSubset<T, PatternEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatternEvents
     * const patternEvent = await prisma.patternEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatternEventUpdateManyArgs>(args: SelectSubset<T, PatternEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternEvents and returns the data updated in the database.
     * @param {PatternEventUpdateManyAndReturnArgs} args - Arguments to update many PatternEvents.
     * @example
     * // Update many PatternEvents
     * const patternEvent = await prisma.patternEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatternEvents and only return the `id`
     * const patternEventWithIdOnly = await prisma.patternEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatternEventUpdateManyAndReturnArgs>(args: SelectSubset<T, PatternEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatternEvent.
     * @param {PatternEventUpsertArgs} args - Arguments to update or create a PatternEvent.
     * @example
     * // Update or create a PatternEvent
     * const patternEvent = await prisma.patternEvent.upsert({
     *   create: {
     *     // ... data to create a PatternEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatternEvent we want to update
     *   }
     * })
     */
    upsert<T extends PatternEventUpsertArgs>(args: SelectSubset<T, PatternEventUpsertArgs<ExtArgs>>): Prisma__PatternEventClient<$Result.GetResult<Prisma.$PatternEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatternEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternEventCountArgs} args - Arguments to filter PatternEvents to count.
     * @example
     * // Count the number of PatternEvents
     * const count = await prisma.patternEvent.count({
     *   where: {
     *     // ... the filter for the PatternEvents we want to count
     *   }
     * })
    **/
    count<T extends PatternEventCountArgs>(
      args?: Subset<T, PatternEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatternEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternEventAggregateArgs>(args: Subset<T, PatternEventAggregateArgs>): Prisma.PrismaPromise<GetPatternEventAggregateType<T>>

    /**
     * Group by PatternEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatternEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternEventGroupByArgs['orderBy'] }
        : { orderBy?: PatternEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatternEvent model
   */
  readonly fields: PatternEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatternEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends PatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatternDefaultArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatternEvent model
   */
  interface PatternEventFieldRefs {
    readonly id: FieldRef<"PatternEvent", 'String'>
    readonly patternId: FieldRef<"PatternEvent", 'String'>
    readonly eventId: FieldRef<"PatternEvent", 'String'>
    readonly addedAt: FieldRef<"PatternEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatternEvent findUnique
   */
  export type PatternEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * Filter, which PatternEvent to fetch.
     */
    where: PatternEventWhereUniqueInput
  }

  /**
   * PatternEvent findUniqueOrThrow
   */
  export type PatternEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * Filter, which PatternEvent to fetch.
     */
    where: PatternEventWhereUniqueInput
  }

  /**
   * PatternEvent findFirst
   */
  export type PatternEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * Filter, which PatternEvent to fetch.
     */
    where?: PatternEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternEvents to fetch.
     */
    orderBy?: PatternEventOrderByWithRelationInput | PatternEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatternEvents.
     */
    cursor?: PatternEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatternEvents.
     */
    distinct?: PatternEventScalarFieldEnum | PatternEventScalarFieldEnum[]
  }

  /**
   * PatternEvent findFirstOrThrow
   */
  export type PatternEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * Filter, which PatternEvent to fetch.
     */
    where?: PatternEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternEvents to fetch.
     */
    orderBy?: PatternEventOrderByWithRelationInput | PatternEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatternEvents.
     */
    cursor?: PatternEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatternEvents.
     */
    distinct?: PatternEventScalarFieldEnum | PatternEventScalarFieldEnum[]
  }

  /**
   * PatternEvent findMany
   */
  export type PatternEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * Filter, which PatternEvents to fetch.
     */
    where?: PatternEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternEvents to fetch.
     */
    orderBy?: PatternEventOrderByWithRelationInput | PatternEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatternEvents.
     */
    cursor?: PatternEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternEvents.
     */
    skip?: number
    distinct?: PatternEventScalarFieldEnum | PatternEventScalarFieldEnum[]
  }

  /**
   * PatternEvent create
   */
  export type PatternEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * The data needed to create a PatternEvent.
     */
    data: XOR<PatternEventCreateInput, PatternEventUncheckedCreateInput>
  }

  /**
   * PatternEvent createMany
   */
  export type PatternEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatternEvents.
     */
    data: PatternEventCreateManyInput | PatternEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatternEvent createManyAndReturn
   */
  export type PatternEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * The data used to create many PatternEvents.
     */
    data: PatternEventCreateManyInput | PatternEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternEvent update
   */
  export type PatternEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * The data needed to update a PatternEvent.
     */
    data: XOR<PatternEventUpdateInput, PatternEventUncheckedUpdateInput>
    /**
     * Choose, which PatternEvent to update.
     */
    where: PatternEventWhereUniqueInput
  }

  /**
   * PatternEvent updateMany
   */
  export type PatternEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatternEvents.
     */
    data: XOR<PatternEventUpdateManyMutationInput, PatternEventUncheckedUpdateManyInput>
    /**
     * Filter which PatternEvents to update
     */
    where?: PatternEventWhereInput
    /**
     * Limit how many PatternEvents to update.
     */
    limit?: number
  }

  /**
   * PatternEvent updateManyAndReturn
   */
  export type PatternEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * The data used to update PatternEvents.
     */
    data: XOR<PatternEventUpdateManyMutationInput, PatternEventUncheckedUpdateManyInput>
    /**
     * Filter which PatternEvents to update
     */
    where?: PatternEventWhereInput
    /**
     * Limit how many PatternEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternEvent upsert
   */
  export type PatternEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * The filter to search for the PatternEvent to update in case it exists.
     */
    where: PatternEventWhereUniqueInput
    /**
     * In case the PatternEvent found by the `where` argument doesn't exist, create a new PatternEvent with this data.
     */
    create: XOR<PatternEventCreateInput, PatternEventUncheckedCreateInput>
    /**
     * In case the PatternEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternEventUpdateInput, PatternEventUncheckedUpdateInput>
  }

  /**
   * PatternEvent delete
   */
  export type PatternEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
    /**
     * Filter which PatternEvent to delete.
     */
    where: PatternEventWhereUniqueInput
  }

  /**
   * PatternEvent deleteMany
   */
  export type PatternEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternEvents to delete
     */
    where?: PatternEventWhereInput
    /**
     * Limit how many PatternEvents to delete.
     */
    limit?: number
  }

  /**
   * PatternEvent without action
   */
  export type PatternEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternEvent
     */
    select?: PatternEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternEvent
     */
    omit?: PatternEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternEventInclude<ExtArgs> | null
  }


  /**
   * Model Insight
   */

  export type AggregateInsight = {
    _count: InsightCountAggregateOutputType | null
    _min: InsightMinAggregateOutputType | null
    _max: InsightMaxAggregateOutputType | null
  }

  export type InsightMinAggregateOutputType = {
    id: string | null
    userId: string | null
    statement: string | null
    explanation: string | null
    confidence: $Enums.ConfidenceLevel | null
    status: $Enums.InsightStatus | null
    category: string | null
    temporalScope: string | null
    supersededById: string | null
    supersedes: string | null
    triggerType: string | null
    triggerEventId: string | null
    firstDetectedAt: Date | null
    lastReinforcedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsightMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    statement: string | null
    explanation: string | null
    confidence: $Enums.ConfidenceLevel | null
    status: $Enums.InsightStatus | null
    category: string | null
    temporalScope: string | null
    supersededById: string | null
    supersedes: string | null
    triggerType: string | null
    triggerEventId: string | null
    firstDetectedAt: Date | null
    lastReinforcedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsightCountAggregateOutputType = {
    id: number
    userId: number
    statement: number
    explanation: number
    confidence: number
    status: number
    category: number
    temporalScope: number
    supersededById: number
    supersedes: number
    triggerType: number
    triggerEventId: number
    firstDetectedAt: number
    lastReinforcedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsightMinAggregateInputType = {
    id?: true
    userId?: true
    statement?: true
    explanation?: true
    confidence?: true
    status?: true
    category?: true
    temporalScope?: true
    supersededById?: true
    supersedes?: true
    triggerType?: true
    triggerEventId?: true
    firstDetectedAt?: true
    lastReinforcedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsightMaxAggregateInputType = {
    id?: true
    userId?: true
    statement?: true
    explanation?: true
    confidence?: true
    status?: true
    category?: true
    temporalScope?: true
    supersededById?: true
    supersedes?: true
    triggerType?: true
    triggerEventId?: true
    firstDetectedAt?: true
    lastReinforcedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsightCountAggregateInputType = {
    id?: true
    userId?: true
    statement?: true
    explanation?: true
    confidence?: true
    status?: true
    category?: true
    temporalScope?: true
    supersededById?: true
    supersedes?: true
    triggerType?: true
    triggerEventId?: true
    firstDetectedAt?: true
    lastReinforcedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insight to aggregate.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insights
    **/
    _count?: true | InsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightMaxAggregateInputType
  }

  export type GetInsightAggregateType<T extends InsightAggregateArgs> = {
        [P in keyof T & keyof AggregateInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsight[P]>
      : GetScalarType<T[P], AggregateInsight[P]>
  }




  export type InsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightWhereInput
    orderBy?: InsightOrderByWithAggregationInput | InsightOrderByWithAggregationInput[]
    by: InsightScalarFieldEnum[] | InsightScalarFieldEnum
    having?: InsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightCountAggregateInputType | true
    _min?: InsightMinAggregateInputType
    _max?: InsightMaxAggregateInputType
  }

  export type InsightGroupByOutputType = {
    id: string
    userId: string
    statement: string
    explanation: string
    confidence: $Enums.ConfidenceLevel
    status: $Enums.InsightStatus
    category: string | null
    temporalScope: string | null
    supersededById: string | null
    supersedes: string | null
    triggerType: string | null
    triggerEventId: string | null
    firstDetectedAt: Date
    lastReinforcedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: InsightCountAggregateOutputType | null
    _min: InsightMinAggregateOutputType | null
    _max: InsightMaxAggregateOutputType | null
  }

  type GetInsightGroupByPayload<T extends InsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightGroupByOutputType[P]>
            : GetScalarType<T[P], InsightGroupByOutputType[P]>
        }
      >
    >


  export type InsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    statement?: boolean
    explanation?: boolean
    confidence?: boolean
    status?: boolean
    category?: boolean
    temporalScope?: boolean
    supersededById?: boolean
    supersedes?: boolean
    triggerType?: boolean
    triggerEventId?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    insightEvents?: boolean | Insight$insightEventsArgs<ExtArgs>
    insightPatterns?: boolean | Insight$insightPatternsArgs<ExtArgs>
    insightInterpretations?: boolean | Insight$insightInterpretationsArgs<ExtArgs>
    _count?: boolean | InsightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    statement?: boolean
    explanation?: boolean
    confidence?: boolean
    status?: boolean
    category?: boolean
    temporalScope?: boolean
    supersededById?: boolean
    supersedes?: boolean
    triggerType?: boolean
    triggerEventId?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    statement?: boolean
    explanation?: boolean
    confidence?: boolean
    status?: boolean
    category?: boolean
    temporalScope?: boolean
    supersededById?: boolean
    supersedes?: boolean
    triggerType?: boolean
    triggerEventId?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectScalar = {
    id?: boolean
    userId?: boolean
    statement?: boolean
    explanation?: boolean
    confidence?: boolean
    status?: boolean
    category?: boolean
    temporalScope?: boolean
    supersededById?: boolean
    supersedes?: boolean
    triggerType?: boolean
    triggerEventId?: boolean
    firstDetectedAt?: boolean
    lastReinforcedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "statement" | "explanation" | "confidence" | "status" | "category" | "temporalScope" | "supersededById" | "supersedes" | "triggerType" | "triggerEventId" | "firstDetectedAt" | "lastReinforcedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["insight"]>
  export type InsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    insightEvents?: boolean | Insight$insightEventsArgs<ExtArgs>
    insightPatterns?: boolean | Insight$insightPatternsArgs<ExtArgs>
    insightInterpretations?: boolean | Insight$insightInterpretationsArgs<ExtArgs>
    _count?: boolean | InsightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Insight"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      insightEvents: Prisma.$InsightEventPayload<ExtArgs>[]
      insightPatterns: Prisma.$InsightPatternPayload<ExtArgs>[]
      insightInterpretations: Prisma.$InsightInterpretationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      statement: string
      explanation: string
      confidence: $Enums.ConfidenceLevel
      status: $Enums.InsightStatus
      category: string | null
      temporalScope: string | null
      supersededById: string | null
      supersedes: string | null
      triggerType: string | null
      triggerEventId: string | null
      firstDetectedAt: Date
      lastReinforcedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["insight"]>
    composites: {}
  }

  type InsightGetPayload<S extends boolean | null | undefined | InsightDefaultArgs> = $Result.GetResult<Prisma.$InsightPayload, S>

  type InsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsightCountAggregateInputType | true
    }

  export interface InsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insight'], meta: { name: 'Insight' } }
    /**
     * Find zero or one Insight that matches the filter.
     * @param {InsightFindUniqueArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightFindUniqueArgs>(args: SelectSubset<T, InsightFindUniqueArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Insight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsightFindUniqueOrThrowArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Insight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindFirstArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightFindFirstArgs>(args?: SelectSubset<T, InsightFindFirstArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Insight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindFirstOrThrowArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Insights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insights
     * const insights = await prisma.insight.findMany()
     * 
     * // Get first 10 Insights
     * const insights = await prisma.insight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightWithIdOnly = await prisma.insight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightFindManyArgs>(args?: SelectSubset<T, InsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Insight.
     * @param {InsightCreateArgs} args - Arguments to create a Insight.
     * @example
     * // Create one Insight
     * const Insight = await prisma.insight.create({
     *   data: {
     *     // ... data to create a Insight
     *   }
     * })
     * 
     */
    create<T extends InsightCreateArgs>(args: SelectSubset<T, InsightCreateArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Insights.
     * @param {InsightCreateManyArgs} args - Arguments to create many Insights.
     * @example
     * // Create many Insights
     * const insight = await prisma.insight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightCreateManyArgs>(args?: SelectSubset<T, InsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Insights and returns the data saved in the database.
     * @param {InsightCreateManyAndReturnArgs} args - Arguments to create many Insights.
     * @example
     * // Create many Insights
     * const insight = await prisma.insight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Insights and only return the `id`
     * const insightWithIdOnly = await prisma.insight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Insight.
     * @param {InsightDeleteArgs} args - Arguments to delete one Insight.
     * @example
     * // Delete one Insight
     * const Insight = await prisma.insight.delete({
     *   where: {
     *     // ... filter to delete one Insight
     *   }
     * })
     * 
     */
    delete<T extends InsightDeleteArgs>(args: SelectSubset<T, InsightDeleteArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Insight.
     * @param {InsightUpdateArgs} args - Arguments to update one Insight.
     * @example
     * // Update one Insight
     * const insight = await prisma.insight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightUpdateArgs>(args: SelectSubset<T, InsightUpdateArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Insights.
     * @param {InsightDeleteManyArgs} args - Arguments to filter Insights to delete.
     * @example
     * // Delete a few Insights
     * const { count } = await prisma.insight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightDeleteManyArgs>(args?: SelectSubset<T, InsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insights
     * const insight = await prisma.insight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightUpdateManyArgs>(args: SelectSubset<T, InsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insights and returns the data updated in the database.
     * @param {InsightUpdateManyAndReturnArgs} args - Arguments to update many Insights.
     * @example
     * // Update many Insights
     * const insight = await prisma.insight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Insights and only return the `id`
     * const insightWithIdOnly = await prisma.insight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsightUpdateManyAndReturnArgs>(args: SelectSubset<T, InsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Insight.
     * @param {InsightUpsertArgs} args - Arguments to update or create a Insight.
     * @example
     * // Update or create a Insight
     * const insight = await prisma.insight.upsert({
     *   create: {
     *     // ... data to create a Insight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insight we want to update
     *   }
     * })
     */
    upsert<T extends InsightUpsertArgs>(args: SelectSubset<T, InsightUpsertArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightCountArgs} args - Arguments to filter Insights to count.
     * @example
     * // Count the number of Insights
     * const count = await prisma.insight.count({
     *   where: {
     *     // ... the filter for the Insights we want to count
     *   }
     * })
    **/
    count<T extends InsightCountArgs>(
      args?: Subset<T, InsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightAggregateArgs>(args: Subset<T, InsightAggregateArgs>): Prisma.PrismaPromise<GetInsightAggregateType<T>>

    /**
     * Group by Insight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightGroupByArgs['orderBy'] }
        : { orderBy?: InsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Insight model
   */
  readonly fields: InsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Insight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    insightEvents<T extends Insight$insightEventsArgs<ExtArgs> = {}>(args?: Subset<T, Insight$insightEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insightPatterns<T extends Insight$insightPatternsArgs<ExtArgs> = {}>(args?: Subset<T, Insight$insightPatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insightInterpretations<T extends Insight$insightInterpretationsArgs<ExtArgs> = {}>(args?: Subset<T, Insight$insightInterpretationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Insight model
   */
  interface InsightFieldRefs {
    readonly id: FieldRef<"Insight", 'String'>
    readonly userId: FieldRef<"Insight", 'String'>
    readonly statement: FieldRef<"Insight", 'String'>
    readonly explanation: FieldRef<"Insight", 'String'>
    readonly confidence: FieldRef<"Insight", 'ConfidenceLevel'>
    readonly status: FieldRef<"Insight", 'InsightStatus'>
    readonly category: FieldRef<"Insight", 'String'>
    readonly temporalScope: FieldRef<"Insight", 'String'>
    readonly supersededById: FieldRef<"Insight", 'String'>
    readonly supersedes: FieldRef<"Insight", 'String'>
    readonly triggerType: FieldRef<"Insight", 'String'>
    readonly triggerEventId: FieldRef<"Insight", 'String'>
    readonly firstDetectedAt: FieldRef<"Insight", 'DateTime'>
    readonly lastReinforcedAt: FieldRef<"Insight", 'DateTime'>
    readonly createdAt: FieldRef<"Insight", 'DateTime'>
    readonly updatedAt: FieldRef<"Insight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Insight findUnique
   */
  export type InsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight findUniqueOrThrow
   */
  export type InsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight findFirst
   */
  export type InsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insights.
     */
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight findFirstOrThrow
   */
  export type InsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insights.
     */
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight findMany
   */
  export type InsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insights to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight create
   */
  export type InsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The data needed to create a Insight.
     */
    data: XOR<InsightCreateInput, InsightUncheckedCreateInput>
  }

  /**
   * Insight createMany
   */
  export type InsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insights.
     */
    data: InsightCreateManyInput | InsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insight createManyAndReturn
   */
  export type InsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * The data used to create many Insights.
     */
    data: InsightCreateManyInput | InsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Insight update
   */
  export type InsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The data needed to update a Insight.
     */
    data: XOR<InsightUpdateInput, InsightUncheckedUpdateInput>
    /**
     * Choose, which Insight to update.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight updateMany
   */
  export type InsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insights.
     */
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyInput>
    /**
     * Filter which Insights to update
     */
    where?: InsightWhereInput
    /**
     * Limit how many Insights to update.
     */
    limit?: number
  }

  /**
   * Insight updateManyAndReturn
   */
  export type InsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * The data used to update Insights.
     */
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyInput>
    /**
     * Filter which Insights to update
     */
    where?: InsightWhereInput
    /**
     * Limit how many Insights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Insight upsert
   */
  export type InsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The filter to search for the Insight to update in case it exists.
     */
    where: InsightWhereUniqueInput
    /**
     * In case the Insight found by the `where` argument doesn't exist, create a new Insight with this data.
     */
    create: XOR<InsightCreateInput, InsightUncheckedCreateInput>
    /**
     * In case the Insight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightUpdateInput, InsightUncheckedUpdateInput>
  }

  /**
   * Insight delete
   */
  export type InsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter which Insight to delete.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight deleteMany
   */
  export type InsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insights to delete
     */
    where?: InsightWhereInput
    /**
     * Limit how many Insights to delete.
     */
    limit?: number
  }

  /**
   * Insight.insightEvents
   */
  export type Insight$insightEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    where?: InsightEventWhereInput
    orderBy?: InsightEventOrderByWithRelationInput | InsightEventOrderByWithRelationInput[]
    cursor?: InsightEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightEventScalarFieldEnum | InsightEventScalarFieldEnum[]
  }

  /**
   * Insight.insightPatterns
   */
  export type Insight$insightPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    where?: InsightPatternWhereInput
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    cursor?: InsightPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * Insight.insightInterpretations
   */
  export type Insight$insightInterpretationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    where?: InsightInterpretationWhereInput
    orderBy?: InsightInterpretationOrderByWithRelationInput | InsightInterpretationOrderByWithRelationInput[]
    cursor?: InsightInterpretationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightInterpretationScalarFieldEnum | InsightInterpretationScalarFieldEnum[]
  }

  /**
   * Insight without action
   */
  export type InsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
  }


  /**
   * Model InsightEvent
   */

  export type AggregateInsightEvent = {
    _count: InsightEventCountAggregateOutputType | null
    _min: InsightEventMinAggregateOutputType | null
    _max: InsightEventMaxAggregateOutputType | null
  }

  export type InsightEventMinAggregateOutputType = {
    id: string | null
    insightId: string | null
    eventId: string | null
    relevance: $Enums.EvidenceRelevance | null
    excerpt: string | null
    addedAt: Date | null
  }

  export type InsightEventMaxAggregateOutputType = {
    id: string | null
    insightId: string | null
    eventId: string | null
    relevance: $Enums.EvidenceRelevance | null
    excerpt: string | null
    addedAt: Date | null
  }

  export type InsightEventCountAggregateOutputType = {
    id: number
    insightId: number
    eventId: number
    relevance: number
    excerpt: number
    addedAt: number
    _all: number
  }


  export type InsightEventMinAggregateInputType = {
    id?: true
    insightId?: true
    eventId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
  }

  export type InsightEventMaxAggregateInputType = {
    id?: true
    insightId?: true
    eventId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
  }

  export type InsightEventCountAggregateInputType = {
    id?: true
    insightId?: true
    eventId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
    _all?: true
  }

  export type InsightEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightEvent to aggregate.
     */
    where?: InsightEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightEvents to fetch.
     */
    orderBy?: InsightEventOrderByWithRelationInput | InsightEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightEvents
    **/
    _count?: true | InsightEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightEventMaxAggregateInputType
  }

  export type GetInsightEventAggregateType<T extends InsightEventAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightEvent[P]>
      : GetScalarType<T[P], AggregateInsightEvent[P]>
  }




  export type InsightEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightEventWhereInput
    orderBy?: InsightEventOrderByWithAggregationInput | InsightEventOrderByWithAggregationInput[]
    by: InsightEventScalarFieldEnum[] | InsightEventScalarFieldEnum
    having?: InsightEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightEventCountAggregateInputType | true
    _min?: InsightEventMinAggregateInputType
    _max?: InsightEventMaxAggregateInputType
  }

  export type InsightEventGroupByOutputType = {
    id: string
    insightId: string
    eventId: string
    relevance: $Enums.EvidenceRelevance
    excerpt: string | null
    addedAt: Date
    _count: InsightEventCountAggregateOutputType | null
    _min: InsightEventMinAggregateOutputType | null
    _max: InsightEventMaxAggregateOutputType | null
  }

  type GetInsightEventGroupByPayload<T extends InsightEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightEventGroupByOutputType[P]>
            : GetScalarType<T[P], InsightEventGroupByOutputType[P]>
        }
      >
    >


  export type InsightEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    eventId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightEvent"]>

  export type InsightEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    eventId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightEvent"]>

  export type InsightEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    eventId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightEvent"]>

  export type InsightEventSelectScalar = {
    id?: boolean
    insightId?: boolean
    eventId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
  }

  export type InsightEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "insightId" | "eventId" | "relevance" | "excerpt" | "addedAt", ExtArgs["result"]["insightEvent"]>
  export type InsightEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type InsightEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type InsightEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $InsightEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightEvent"
    objects: {
      insight: Prisma.$InsightPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insightId: string
      eventId: string
      relevance: $Enums.EvidenceRelevance
      excerpt: string | null
      addedAt: Date
    }, ExtArgs["result"]["insightEvent"]>
    composites: {}
  }

  type InsightEventGetPayload<S extends boolean | null | undefined | InsightEventDefaultArgs> = $Result.GetResult<Prisma.$InsightEventPayload, S>

  type InsightEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsightEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsightEventCountAggregateInputType | true
    }

  export interface InsightEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightEvent'], meta: { name: 'InsightEvent' } }
    /**
     * Find zero or one InsightEvent that matches the filter.
     * @param {InsightEventFindUniqueArgs} args - Arguments to find a InsightEvent
     * @example
     * // Get one InsightEvent
     * const insightEvent = await prisma.insightEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightEventFindUniqueArgs>(args: SelectSubset<T, InsightEventFindUniqueArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsightEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsightEventFindUniqueOrThrowArgs} args - Arguments to find a InsightEvent
     * @example
     * // Get one InsightEvent
     * const insightEvent = await prisma.insightEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightEventFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightEventFindFirstArgs} args - Arguments to find a InsightEvent
     * @example
     * // Get one InsightEvent
     * const insightEvent = await prisma.insightEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightEventFindFirstArgs>(args?: SelectSubset<T, InsightEventFindFirstArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightEventFindFirstOrThrowArgs} args - Arguments to find a InsightEvent
     * @example
     * // Get one InsightEvent
     * const insightEvent = await prisma.insightEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightEventFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsightEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightEvents
     * const insightEvents = await prisma.insightEvent.findMany()
     * 
     * // Get first 10 InsightEvents
     * const insightEvents = await prisma.insightEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightEventWithIdOnly = await prisma.insightEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightEventFindManyArgs>(args?: SelectSubset<T, InsightEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsightEvent.
     * @param {InsightEventCreateArgs} args - Arguments to create a InsightEvent.
     * @example
     * // Create one InsightEvent
     * const InsightEvent = await prisma.insightEvent.create({
     *   data: {
     *     // ... data to create a InsightEvent
     *   }
     * })
     * 
     */
    create<T extends InsightEventCreateArgs>(args: SelectSubset<T, InsightEventCreateArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsightEvents.
     * @param {InsightEventCreateManyArgs} args - Arguments to create many InsightEvents.
     * @example
     * // Create many InsightEvents
     * const insightEvent = await prisma.insightEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightEventCreateManyArgs>(args?: SelectSubset<T, InsightEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightEvents and returns the data saved in the database.
     * @param {InsightEventCreateManyAndReturnArgs} args - Arguments to create many InsightEvents.
     * @example
     * // Create many InsightEvents
     * const insightEvent = await prisma.insightEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightEvents and only return the `id`
     * const insightEventWithIdOnly = await prisma.insightEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightEventCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsightEvent.
     * @param {InsightEventDeleteArgs} args - Arguments to delete one InsightEvent.
     * @example
     * // Delete one InsightEvent
     * const InsightEvent = await prisma.insightEvent.delete({
     *   where: {
     *     // ... filter to delete one InsightEvent
     *   }
     * })
     * 
     */
    delete<T extends InsightEventDeleteArgs>(args: SelectSubset<T, InsightEventDeleteArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsightEvent.
     * @param {InsightEventUpdateArgs} args - Arguments to update one InsightEvent.
     * @example
     * // Update one InsightEvent
     * const insightEvent = await prisma.insightEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightEventUpdateArgs>(args: SelectSubset<T, InsightEventUpdateArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsightEvents.
     * @param {InsightEventDeleteManyArgs} args - Arguments to filter InsightEvents to delete.
     * @example
     * // Delete a few InsightEvents
     * const { count } = await prisma.insightEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightEventDeleteManyArgs>(args?: SelectSubset<T, InsightEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightEvents
     * const insightEvent = await prisma.insightEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightEventUpdateManyArgs>(args: SelectSubset<T, InsightEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightEvents and returns the data updated in the database.
     * @param {InsightEventUpdateManyAndReturnArgs} args - Arguments to update many InsightEvents.
     * @example
     * // Update many InsightEvents
     * const insightEvent = await prisma.insightEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsightEvents and only return the `id`
     * const insightEventWithIdOnly = await prisma.insightEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsightEventUpdateManyAndReturnArgs>(args: SelectSubset<T, InsightEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsightEvent.
     * @param {InsightEventUpsertArgs} args - Arguments to update or create a InsightEvent.
     * @example
     * // Update or create a InsightEvent
     * const insightEvent = await prisma.insightEvent.upsert({
     *   create: {
     *     // ... data to create a InsightEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightEvent we want to update
     *   }
     * })
     */
    upsert<T extends InsightEventUpsertArgs>(args: SelectSubset<T, InsightEventUpsertArgs<ExtArgs>>): Prisma__InsightEventClient<$Result.GetResult<Prisma.$InsightEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsightEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightEventCountArgs} args - Arguments to filter InsightEvents to count.
     * @example
     * // Count the number of InsightEvents
     * const count = await prisma.insightEvent.count({
     *   where: {
     *     // ... the filter for the InsightEvents we want to count
     *   }
     * })
    **/
    count<T extends InsightEventCountArgs>(
      args?: Subset<T, InsightEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightEventAggregateArgs>(args: Subset<T, InsightEventAggregateArgs>): Prisma.PrismaPromise<GetInsightEventAggregateType<T>>

    /**
     * Group by InsightEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightEventGroupByArgs['orderBy'] }
        : { orderBy?: InsightEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightEvent model
   */
  readonly fields: InsightEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insight<T extends InsightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsightDefaultArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightEvent model
   */
  interface InsightEventFieldRefs {
    readonly id: FieldRef<"InsightEvent", 'String'>
    readonly insightId: FieldRef<"InsightEvent", 'String'>
    readonly eventId: FieldRef<"InsightEvent", 'String'>
    readonly relevance: FieldRef<"InsightEvent", 'EvidenceRelevance'>
    readonly excerpt: FieldRef<"InsightEvent", 'String'>
    readonly addedAt: FieldRef<"InsightEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsightEvent findUnique
   */
  export type InsightEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * Filter, which InsightEvent to fetch.
     */
    where: InsightEventWhereUniqueInput
  }

  /**
   * InsightEvent findUniqueOrThrow
   */
  export type InsightEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * Filter, which InsightEvent to fetch.
     */
    where: InsightEventWhereUniqueInput
  }

  /**
   * InsightEvent findFirst
   */
  export type InsightEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * Filter, which InsightEvent to fetch.
     */
    where?: InsightEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightEvents to fetch.
     */
    orderBy?: InsightEventOrderByWithRelationInput | InsightEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightEvents.
     */
    cursor?: InsightEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightEvents.
     */
    distinct?: InsightEventScalarFieldEnum | InsightEventScalarFieldEnum[]
  }

  /**
   * InsightEvent findFirstOrThrow
   */
  export type InsightEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * Filter, which InsightEvent to fetch.
     */
    where?: InsightEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightEvents to fetch.
     */
    orderBy?: InsightEventOrderByWithRelationInput | InsightEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightEvents.
     */
    cursor?: InsightEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightEvents.
     */
    distinct?: InsightEventScalarFieldEnum | InsightEventScalarFieldEnum[]
  }

  /**
   * InsightEvent findMany
   */
  export type InsightEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * Filter, which InsightEvents to fetch.
     */
    where?: InsightEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightEvents to fetch.
     */
    orderBy?: InsightEventOrderByWithRelationInput | InsightEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightEvents.
     */
    cursor?: InsightEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightEvents.
     */
    skip?: number
    distinct?: InsightEventScalarFieldEnum | InsightEventScalarFieldEnum[]
  }

  /**
   * InsightEvent create
   */
  export type InsightEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightEvent.
     */
    data: XOR<InsightEventCreateInput, InsightEventUncheckedCreateInput>
  }

  /**
   * InsightEvent createMany
   */
  export type InsightEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightEvents.
     */
    data: InsightEventCreateManyInput | InsightEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightEvent createManyAndReturn
   */
  export type InsightEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * The data used to create many InsightEvents.
     */
    data: InsightEventCreateManyInput | InsightEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightEvent update
   */
  export type InsightEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightEvent.
     */
    data: XOR<InsightEventUpdateInput, InsightEventUncheckedUpdateInput>
    /**
     * Choose, which InsightEvent to update.
     */
    where: InsightEventWhereUniqueInput
  }

  /**
   * InsightEvent updateMany
   */
  export type InsightEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightEvents.
     */
    data: XOR<InsightEventUpdateManyMutationInput, InsightEventUncheckedUpdateManyInput>
    /**
     * Filter which InsightEvents to update
     */
    where?: InsightEventWhereInput
    /**
     * Limit how many InsightEvents to update.
     */
    limit?: number
  }

  /**
   * InsightEvent updateManyAndReturn
   */
  export type InsightEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * The data used to update InsightEvents.
     */
    data: XOR<InsightEventUpdateManyMutationInput, InsightEventUncheckedUpdateManyInput>
    /**
     * Filter which InsightEvents to update
     */
    where?: InsightEventWhereInput
    /**
     * Limit how many InsightEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightEvent upsert
   */
  export type InsightEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightEvent to update in case it exists.
     */
    where: InsightEventWhereUniqueInput
    /**
     * In case the InsightEvent found by the `where` argument doesn't exist, create a new InsightEvent with this data.
     */
    create: XOR<InsightEventCreateInput, InsightEventUncheckedCreateInput>
    /**
     * In case the InsightEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightEventUpdateInput, InsightEventUncheckedUpdateInput>
  }

  /**
   * InsightEvent delete
   */
  export type InsightEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
    /**
     * Filter which InsightEvent to delete.
     */
    where: InsightEventWhereUniqueInput
  }

  /**
   * InsightEvent deleteMany
   */
  export type InsightEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightEvents to delete
     */
    where?: InsightEventWhereInput
    /**
     * Limit how many InsightEvents to delete.
     */
    limit?: number
  }

  /**
   * InsightEvent without action
   */
  export type InsightEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightEvent
     */
    select?: InsightEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightEvent
     */
    omit?: InsightEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightEventInclude<ExtArgs> | null
  }


  /**
   * Model InsightPattern
   */

  export type AggregateInsightPattern = {
    _count: InsightPatternCountAggregateOutputType | null
    _min: InsightPatternMinAggregateOutputType | null
    _max: InsightPatternMaxAggregateOutputType | null
  }

  export type InsightPatternMinAggregateOutputType = {
    id: string | null
    insightId: string | null
    patternId: string | null
    relevance: $Enums.EvidenceRelevance | null
    excerpt: string | null
    addedAt: Date | null
  }

  export type InsightPatternMaxAggregateOutputType = {
    id: string | null
    insightId: string | null
    patternId: string | null
    relevance: $Enums.EvidenceRelevance | null
    excerpt: string | null
    addedAt: Date | null
  }

  export type InsightPatternCountAggregateOutputType = {
    id: number
    insightId: number
    patternId: number
    relevance: number
    excerpt: number
    addedAt: number
    _all: number
  }


  export type InsightPatternMinAggregateInputType = {
    id?: true
    insightId?: true
    patternId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
  }

  export type InsightPatternMaxAggregateInputType = {
    id?: true
    insightId?: true
    patternId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
  }

  export type InsightPatternCountAggregateInputType = {
    id?: true
    insightId?: true
    patternId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
    _all?: true
  }

  export type InsightPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightPattern to aggregate.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightPatterns
    **/
    _count?: true | InsightPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightPatternMaxAggregateInputType
  }

  export type GetInsightPatternAggregateType<T extends InsightPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightPattern[P]>
      : GetScalarType<T[P], AggregateInsightPattern[P]>
  }




  export type InsightPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightPatternWhereInput
    orderBy?: InsightPatternOrderByWithAggregationInput | InsightPatternOrderByWithAggregationInput[]
    by: InsightPatternScalarFieldEnum[] | InsightPatternScalarFieldEnum
    having?: InsightPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightPatternCountAggregateInputType | true
    _min?: InsightPatternMinAggregateInputType
    _max?: InsightPatternMaxAggregateInputType
  }

  export type InsightPatternGroupByOutputType = {
    id: string
    insightId: string
    patternId: string
    relevance: $Enums.EvidenceRelevance
    excerpt: string | null
    addedAt: Date
    _count: InsightPatternCountAggregateOutputType | null
    _min: InsightPatternMinAggregateOutputType | null
    _max: InsightPatternMaxAggregateOutputType | null
  }

  type GetInsightPatternGroupByPayload<T extends InsightPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightPatternGroupByOutputType[P]>
            : GetScalarType<T[P], InsightPatternGroupByOutputType[P]>
        }
      >
    >


  export type InsightPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    patternId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightPattern"]>

  export type InsightPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    patternId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightPattern"]>

  export type InsightPatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    patternId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightPattern"]>

  export type InsightPatternSelectScalar = {
    id?: boolean
    insightId?: boolean
    patternId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
  }

  export type InsightPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "insightId" | "patternId" | "relevance" | "excerpt" | "addedAt", ExtArgs["result"]["insightPattern"]>
  export type InsightPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }
  export type InsightPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }
  export type InsightPatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }

  export type $InsightPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightPattern"
    objects: {
      insight: Prisma.$InsightPayload<ExtArgs>
      pattern: Prisma.$PatternPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insightId: string
      patternId: string
      relevance: $Enums.EvidenceRelevance
      excerpt: string | null
      addedAt: Date
    }, ExtArgs["result"]["insightPattern"]>
    composites: {}
  }

  type InsightPatternGetPayload<S extends boolean | null | undefined | InsightPatternDefaultArgs> = $Result.GetResult<Prisma.$InsightPatternPayload, S>

  type InsightPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsightPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsightPatternCountAggregateInputType | true
    }

  export interface InsightPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightPattern'], meta: { name: 'InsightPattern' } }
    /**
     * Find zero or one InsightPattern that matches the filter.
     * @param {InsightPatternFindUniqueArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightPatternFindUniqueArgs>(args: SelectSubset<T, InsightPatternFindUniqueArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsightPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsightPatternFindUniqueOrThrowArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternFindFirstArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightPatternFindFirstArgs>(args?: SelectSubset<T, InsightPatternFindFirstArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternFindFirstOrThrowArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsightPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightPatterns
     * const insightPatterns = await prisma.insightPattern.findMany()
     * 
     * // Get first 10 InsightPatterns
     * const insightPatterns = await prisma.insightPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightPatternWithIdOnly = await prisma.insightPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightPatternFindManyArgs>(args?: SelectSubset<T, InsightPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsightPattern.
     * @param {InsightPatternCreateArgs} args - Arguments to create a InsightPattern.
     * @example
     * // Create one InsightPattern
     * const InsightPattern = await prisma.insightPattern.create({
     *   data: {
     *     // ... data to create a InsightPattern
     *   }
     * })
     * 
     */
    create<T extends InsightPatternCreateArgs>(args: SelectSubset<T, InsightPatternCreateArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsightPatterns.
     * @param {InsightPatternCreateManyArgs} args - Arguments to create many InsightPatterns.
     * @example
     * // Create many InsightPatterns
     * const insightPattern = await prisma.insightPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightPatternCreateManyArgs>(args?: SelectSubset<T, InsightPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightPatterns and returns the data saved in the database.
     * @param {InsightPatternCreateManyAndReturnArgs} args - Arguments to create many InsightPatterns.
     * @example
     * // Create many InsightPatterns
     * const insightPattern = await prisma.insightPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightPatterns and only return the `id`
     * const insightPatternWithIdOnly = await prisma.insightPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsightPattern.
     * @param {InsightPatternDeleteArgs} args - Arguments to delete one InsightPattern.
     * @example
     * // Delete one InsightPattern
     * const InsightPattern = await prisma.insightPattern.delete({
     *   where: {
     *     // ... filter to delete one InsightPattern
     *   }
     * })
     * 
     */
    delete<T extends InsightPatternDeleteArgs>(args: SelectSubset<T, InsightPatternDeleteArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsightPattern.
     * @param {InsightPatternUpdateArgs} args - Arguments to update one InsightPattern.
     * @example
     * // Update one InsightPattern
     * const insightPattern = await prisma.insightPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightPatternUpdateArgs>(args: SelectSubset<T, InsightPatternUpdateArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsightPatterns.
     * @param {InsightPatternDeleteManyArgs} args - Arguments to filter InsightPatterns to delete.
     * @example
     * // Delete a few InsightPatterns
     * const { count } = await prisma.insightPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightPatternDeleteManyArgs>(args?: SelectSubset<T, InsightPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightPatterns
     * const insightPattern = await prisma.insightPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightPatternUpdateManyArgs>(args: SelectSubset<T, InsightPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightPatterns and returns the data updated in the database.
     * @param {InsightPatternUpdateManyAndReturnArgs} args - Arguments to update many InsightPatterns.
     * @example
     * // Update many InsightPatterns
     * const insightPattern = await prisma.insightPattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsightPatterns and only return the `id`
     * const insightPatternWithIdOnly = await prisma.insightPattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsightPatternUpdateManyAndReturnArgs>(args: SelectSubset<T, InsightPatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsightPattern.
     * @param {InsightPatternUpsertArgs} args - Arguments to update or create a InsightPattern.
     * @example
     * // Update or create a InsightPattern
     * const insightPattern = await prisma.insightPattern.upsert({
     *   create: {
     *     // ... data to create a InsightPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightPattern we want to update
     *   }
     * })
     */
    upsert<T extends InsightPatternUpsertArgs>(args: SelectSubset<T, InsightPatternUpsertArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsightPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternCountArgs} args - Arguments to filter InsightPatterns to count.
     * @example
     * // Count the number of InsightPatterns
     * const count = await prisma.insightPattern.count({
     *   where: {
     *     // ... the filter for the InsightPatterns we want to count
     *   }
     * })
    **/
    count<T extends InsightPatternCountArgs>(
      args?: Subset<T, InsightPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightPatternAggregateArgs>(args: Subset<T, InsightPatternAggregateArgs>): Prisma.PrismaPromise<GetInsightPatternAggregateType<T>>

    /**
     * Group by InsightPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightPatternGroupByArgs['orderBy'] }
        : { orderBy?: InsightPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightPattern model
   */
  readonly fields: InsightPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insight<T extends InsightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsightDefaultArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pattern<T extends PatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatternDefaultArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightPattern model
   */
  interface InsightPatternFieldRefs {
    readonly id: FieldRef<"InsightPattern", 'String'>
    readonly insightId: FieldRef<"InsightPattern", 'String'>
    readonly patternId: FieldRef<"InsightPattern", 'String'>
    readonly relevance: FieldRef<"InsightPattern", 'EvidenceRelevance'>
    readonly excerpt: FieldRef<"InsightPattern", 'String'>
    readonly addedAt: FieldRef<"InsightPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsightPattern findUnique
   */
  export type InsightPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern findUniqueOrThrow
   */
  export type InsightPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern findFirst
   */
  export type InsightPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightPatterns.
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightPatterns.
     */
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * InsightPattern findFirstOrThrow
   */
  export type InsightPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightPatterns.
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightPatterns.
     */
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * InsightPattern findMany
   */
  export type InsightPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPatterns to fetch.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightPatterns.
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * InsightPattern create
   */
  export type InsightPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightPattern.
     */
    data: XOR<InsightPatternCreateInput, InsightPatternUncheckedCreateInput>
  }

  /**
   * InsightPattern createMany
   */
  export type InsightPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightPatterns.
     */
    data: InsightPatternCreateManyInput | InsightPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightPattern createManyAndReturn
   */
  export type InsightPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * The data used to create many InsightPatterns.
     */
    data: InsightPatternCreateManyInput | InsightPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightPattern update
   */
  export type InsightPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightPattern.
     */
    data: XOR<InsightPatternUpdateInput, InsightPatternUncheckedUpdateInput>
    /**
     * Choose, which InsightPattern to update.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern updateMany
   */
  export type InsightPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightPatterns.
     */
    data: XOR<InsightPatternUpdateManyMutationInput, InsightPatternUncheckedUpdateManyInput>
    /**
     * Filter which InsightPatterns to update
     */
    where?: InsightPatternWhereInput
    /**
     * Limit how many InsightPatterns to update.
     */
    limit?: number
  }

  /**
   * InsightPattern updateManyAndReturn
   */
  export type InsightPatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * The data used to update InsightPatterns.
     */
    data: XOR<InsightPatternUpdateManyMutationInput, InsightPatternUncheckedUpdateManyInput>
    /**
     * Filter which InsightPatterns to update
     */
    where?: InsightPatternWhereInput
    /**
     * Limit how many InsightPatterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightPattern upsert
   */
  export type InsightPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightPattern to update in case it exists.
     */
    where: InsightPatternWhereUniqueInput
    /**
     * In case the InsightPattern found by the `where` argument doesn't exist, create a new InsightPattern with this data.
     */
    create: XOR<InsightPatternCreateInput, InsightPatternUncheckedCreateInput>
    /**
     * In case the InsightPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightPatternUpdateInput, InsightPatternUncheckedUpdateInput>
  }

  /**
   * InsightPattern delete
   */
  export type InsightPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter which InsightPattern to delete.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern deleteMany
   */
  export type InsightPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightPatterns to delete
     */
    where?: InsightPatternWhereInput
    /**
     * Limit how many InsightPatterns to delete.
     */
    limit?: number
  }

  /**
   * InsightPattern without action
   */
  export type InsightPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightPattern
     */
    omit?: InsightPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
  }


  /**
   * Model InsightInterpretation
   */

  export type AggregateInsightInterpretation = {
    _count: InsightInterpretationCountAggregateOutputType | null
    _min: InsightInterpretationMinAggregateOutputType | null
    _max: InsightInterpretationMaxAggregateOutputType | null
  }

  export type InsightInterpretationMinAggregateOutputType = {
    id: string | null
    insightId: string | null
    interpretationId: string | null
    relevance: $Enums.EvidenceRelevance | null
    excerpt: string | null
    addedAt: Date | null
  }

  export type InsightInterpretationMaxAggregateOutputType = {
    id: string | null
    insightId: string | null
    interpretationId: string | null
    relevance: $Enums.EvidenceRelevance | null
    excerpt: string | null
    addedAt: Date | null
  }

  export type InsightInterpretationCountAggregateOutputType = {
    id: number
    insightId: number
    interpretationId: number
    relevance: number
    excerpt: number
    addedAt: number
    _all: number
  }


  export type InsightInterpretationMinAggregateInputType = {
    id?: true
    insightId?: true
    interpretationId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
  }

  export type InsightInterpretationMaxAggregateInputType = {
    id?: true
    insightId?: true
    interpretationId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
  }

  export type InsightInterpretationCountAggregateInputType = {
    id?: true
    insightId?: true
    interpretationId?: true
    relevance?: true
    excerpt?: true
    addedAt?: true
    _all?: true
  }

  export type InsightInterpretationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightInterpretation to aggregate.
     */
    where?: InsightInterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightInterpretations to fetch.
     */
    orderBy?: InsightInterpretationOrderByWithRelationInput | InsightInterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightInterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightInterpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightInterpretations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightInterpretations
    **/
    _count?: true | InsightInterpretationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightInterpretationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightInterpretationMaxAggregateInputType
  }

  export type GetInsightInterpretationAggregateType<T extends InsightInterpretationAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightInterpretation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightInterpretation[P]>
      : GetScalarType<T[P], AggregateInsightInterpretation[P]>
  }




  export type InsightInterpretationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightInterpretationWhereInput
    orderBy?: InsightInterpretationOrderByWithAggregationInput | InsightInterpretationOrderByWithAggregationInput[]
    by: InsightInterpretationScalarFieldEnum[] | InsightInterpretationScalarFieldEnum
    having?: InsightInterpretationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightInterpretationCountAggregateInputType | true
    _min?: InsightInterpretationMinAggregateInputType
    _max?: InsightInterpretationMaxAggregateInputType
  }

  export type InsightInterpretationGroupByOutputType = {
    id: string
    insightId: string
    interpretationId: string
    relevance: $Enums.EvidenceRelevance
    excerpt: string | null
    addedAt: Date
    _count: InsightInterpretationCountAggregateOutputType | null
    _min: InsightInterpretationMinAggregateOutputType | null
    _max: InsightInterpretationMaxAggregateOutputType | null
  }

  type GetInsightInterpretationGroupByPayload<T extends InsightInterpretationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightInterpretationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightInterpretationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightInterpretationGroupByOutputType[P]>
            : GetScalarType<T[P], InsightInterpretationGroupByOutputType[P]>
        }
      >
    >


  export type InsightInterpretationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    interpretationId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    interpretation?: boolean | InterpretationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightInterpretation"]>

  export type InsightInterpretationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    interpretationId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    interpretation?: boolean | InterpretationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightInterpretation"]>

  export type InsightInterpretationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    interpretationId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    interpretation?: boolean | InterpretationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightInterpretation"]>

  export type InsightInterpretationSelectScalar = {
    id?: boolean
    insightId?: boolean
    interpretationId?: boolean
    relevance?: boolean
    excerpt?: boolean
    addedAt?: boolean
  }

  export type InsightInterpretationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "insightId" | "interpretationId" | "relevance" | "excerpt" | "addedAt", ExtArgs["result"]["insightInterpretation"]>
  export type InsightInterpretationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    interpretation?: boolean | InterpretationDefaultArgs<ExtArgs>
  }
  export type InsightInterpretationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    interpretation?: boolean | InterpretationDefaultArgs<ExtArgs>
  }
  export type InsightInterpretationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    interpretation?: boolean | InterpretationDefaultArgs<ExtArgs>
  }

  export type $InsightInterpretationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightInterpretation"
    objects: {
      insight: Prisma.$InsightPayload<ExtArgs>
      interpretation: Prisma.$InterpretationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insightId: string
      interpretationId: string
      relevance: $Enums.EvidenceRelevance
      excerpt: string | null
      addedAt: Date
    }, ExtArgs["result"]["insightInterpretation"]>
    composites: {}
  }

  type InsightInterpretationGetPayload<S extends boolean | null | undefined | InsightInterpretationDefaultArgs> = $Result.GetResult<Prisma.$InsightInterpretationPayload, S>

  type InsightInterpretationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsightInterpretationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsightInterpretationCountAggregateInputType | true
    }

  export interface InsightInterpretationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightInterpretation'], meta: { name: 'InsightInterpretation' } }
    /**
     * Find zero or one InsightInterpretation that matches the filter.
     * @param {InsightInterpretationFindUniqueArgs} args - Arguments to find a InsightInterpretation
     * @example
     * // Get one InsightInterpretation
     * const insightInterpretation = await prisma.insightInterpretation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightInterpretationFindUniqueArgs>(args: SelectSubset<T, InsightInterpretationFindUniqueArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsightInterpretation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsightInterpretationFindUniqueOrThrowArgs} args - Arguments to find a InsightInterpretation
     * @example
     * // Get one InsightInterpretation
     * const insightInterpretation = await prisma.insightInterpretation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightInterpretationFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightInterpretationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightInterpretation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightInterpretationFindFirstArgs} args - Arguments to find a InsightInterpretation
     * @example
     * // Get one InsightInterpretation
     * const insightInterpretation = await prisma.insightInterpretation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightInterpretationFindFirstArgs>(args?: SelectSubset<T, InsightInterpretationFindFirstArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightInterpretation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightInterpretationFindFirstOrThrowArgs} args - Arguments to find a InsightInterpretation
     * @example
     * // Get one InsightInterpretation
     * const insightInterpretation = await prisma.insightInterpretation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightInterpretationFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightInterpretationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsightInterpretations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightInterpretationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightInterpretations
     * const insightInterpretations = await prisma.insightInterpretation.findMany()
     * 
     * // Get first 10 InsightInterpretations
     * const insightInterpretations = await prisma.insightInterpretation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightInterpretationWithIdOnly = await prisma.insightInterpretation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightInterpretationFindManyArgs>(args?: SelectSubset<T, InsightInterpretationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsightInterpretation.
     * @param {InsightInterpretationCreateArgs} args - Arguments to create a InsightInterpretation.
     * @example
     * // Create one InsightInterpretation
     * const InsightInterpretation = await prisma.insightInterpretation.create({
     *   data: {
     *     // ... data to create a InsightInterpretation
     *   }
     * })
     * 
     */
    create<T extends InsightInterpretationCreateArgs>(args: SelectSubset<T, InsightInterpretationCreateArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsightInterpretations.
     * @param {InsightInterpretationCreateManyArgs} args - Arguments to create many InsightInterpretations.
     * @example
     * // Create many InsightInterpretations
     * const insightInterpretation = await prisma.insightInterpretation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightInterpretationCreateManyArgs>(args?: SelectSubset<T, InsightInterpretationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightInterpretations and returns the data saved in the database.
     * @param {InsightInterpretationCreateManyAndReturnArgs} args - Arguments to create many InsightInterpretations.
     * @example
     * // Create many InsightInterpretations
     * const insightInterpretation = await prisma.insightInterpretation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightInterpretations and only return the `id`
     * const insightInterpretationWithIdOnly = await prisma.insightInterpretation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightInterpretationCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightInterpretationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsightInterpretation.
     * @param {InsightInterpretationDeleteArgs} args - Arguments to delete one InsightInterpretation.
     * @example
     * // Delete one InsightInterpretation
     * const InsightInterpretation = await prisma.insightInterpretation.delete({
     *   where: {
     *     // ... filter to delete one InsightInterpretation
     *   }
     * })
     * 
     */
    delete<T extends InsightInterpretationDeleteArgs>(args: SelectSubset<T, InsightInterpretationDeleteArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsightInterpretation.
     * @param {InsightInterpretationUpdateArgs} args - Arguments to update one InsightInterpretation.
     * @example
     * // Update one InsightInterpretation
     * const insightInterpretation = await prisma.insightInterpretation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightInterpretationUpdateArgs>(args: SelectSubset<T, InsightInterpretationUpdateArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsightInterpretations.
     * @param {InsightInterpretationDeleteManyArgs} args - Arguments to filter InsightInterpretations to delete.
     * @example
     * // Delete a few InsightInterpretations
     * const { count } = await prisma.insightInterpretation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightInterpretationDeleteManyArgs>(args?: SelectSubset<T, InsightInterpretationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightInterpretations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightInterpretationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightInterpretations
     * const insightInterpretation = await prisma.insightInterpretation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightInterpretationUpdateManyArgs>(args: SelectSubset<T, InsightInterpretationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightInterpretations and returns the data updated in the database.
     * @param {InsightInterpretationUpdateManyAndReturnArgs} args - Arguments to update many InsightInterpretations.
     * @example
     * // Update many InsightInterpretations
     * const insightInterpretation = await prisma.insightInterpretation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsightInterpretations and only return the `id`
     * const insightInterpretationWithIdOnly = await prisma.insightInterpretation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsightInterpretationUpdateManyAndReturnArgs>(args: SelectSubset<T, InsightInterpretationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsightInterpretation.
     * @param {InsightInterpretationUpsertArgs} args - Arguments to update or create a InsightInterpretation.
     * @example
     * // Update or create a InsightInterpretation
     * const insightInterpretation = await prisma.insightInterpretation.upsert({
     *   create: {
     *     // ... data to create a InsightInterpretation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightInterpretation we want to update
     *   }
     * })
     */
    upsert<T extends InsightInterpretationUpsertArgs>(args: SelectSubset<T, InsightInterpretationUpsertArgs<ExtArgs>>): Prisma__InsightInterpretationClient<$Result.GetResult<Prisma.$InsightInterpretationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsightInterpretations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightInterpretationCountArgs} args - Arguments to filter InsightInterpretations to count.
     * @example
     * // Count the number of InsightInterpretations
     * const count = await prisma.insightInterpretation.count({
     *   where: {
     *     // ... the filter for the InsightInterpretations we want to count
     *   }
     * })
    **/
    count<T extends InsightInterpretationCountArgs>(
      args?: Subset<T, InsightInterpretationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightInterpretationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightInterpretation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightInterpretationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightInterpretationAggregateArgs>(args: Subset<T, InsightInterpretationAggregateArgs>): Prisma.PrismaPromise<GetInsightInterpretationAggregateType<T>>

    /**
     * Group by InsightInterpretation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightInterpretationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightInterpretationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightInterpretationGroupByArgs['orderBy'] }
        : { orderBy?: InsightInterpretationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightInterpretationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightInterpretationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightInterpretation model
   */
  readonly fields: InsightInterpretationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightInterpretation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightInterpretationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insight<T extends InsightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsightDefaultArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interpretation<T extends InterpretationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterpretationDefaultArgs<ExtArgs>>): Prisma__InterpretationClient<$Result.GetResult<Prisma.$InterpretationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightInterpretation model
   */
  interface InsightInterpretationFieldRefs {
    readonly id: FieldRef<"InsightInterpretation", 'String'>
    readonly insightId: FieldRef<"InsightInterpretation", 'String'>
    readonly interpretationId: FieldRef<"InsightInterpretation", 'String'>
    readonly relevance: FieldRef<"InsightInterpretation", 'EvidenceRelevance'>
    readonly excerpt: FieldRef<"InsightInterpretation", 'String'>
    readonly addedAt: FieldRef<"InsightInterpretation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsightInterpretation findUnique
   */
  export type InsightInterpretationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * Filter, which InsightInterpretation to fetch.
     */
    where: InsightInterpretationWhereUniqueInput
  }

  /**
   * InsightInterpretation findUniqueOrThrow
   */
  export type InsightInterpretationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * Filter, which InsightInterpretation to fetch.
     */
    where: InsightInterpretationWhereUniqueInput
  }

  /**
   * InsightInterpretation findFirst
   */
  export type InsightInterpretationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * Filter, which InsightInterpretation to fetch.
     */
    where?: InsightInterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightInterpretations to fetch.
     */
    orderBy?: InsightInterpretationOrderByWithRelationInput | InsightInterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightInterpretations.
     */
    cursor?: InsightInterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightInterpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightInterpretations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightInterpretations.
     */
    distinct?: InsightInterpretationScalarFieldEnum | InsightInterpretationScalarFieldEnum[]
  }

  /**
   * InsightInterpretation findFirstOrThrow
   */
  export type InsightInterpretationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * Filter, which InsightInterpretation to fetch.
     */
    where?: InsightInterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightInterpretations to fetch.
     */
    orderBy?: InsightInterpretationOrderByWithRelationInput | InsightInterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightInterpretations.
     */
    cursor?: InsightInterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightInterpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightInterpretations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightInterpretations.
     */
    distinct?: InsightInterpretationScalarFieldEnum | InsightInterpretationScalarFieldEnum[]
  }

  /**
   * InsightInterpretation findMany
   */
  export type InsightInterpretationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * Filter, which InsightInterpretations to fetch.
     */
    where?: InsightInterpretationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightInterpretations to fetch.
     */
    orderBy?: InsightInterpretationOrderByWithRelationInput | InsightInterpretationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightInterpretations.
     */
    cursor?: InsightInterpretationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightInterpretations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightInterpretations.
     */
    skip?: number
    distinct?: InsightInterpretationScalarFieldEnum | InsightInterpretationScalarFieldEnum[]
  }

  /**
   * InsightInterpretation create
   */
  export type InsightInterpretationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightInterpretation.
     */
    data: XOR<InsightInterpretationCreateInput, InsightInterpretationUncheckedCreateInput>
  }

  /**
   * InsightInterpretation createMany
   */
  export type InsightInterpretationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightInterpretations.
     */
    data: InsightInterpretationCreateManyInput | InsightInterpretationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightInterpretation createManyAndReturn
   */
  export type InsightInterpretationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * The data used to create many InsightInterpretations.
     */
    data: InsightInterpretationCreateManyInput | InsightInterpretationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightInterpretation update
   */
  export type InsightInterpretationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightInterpretation.
     */
    data: XOR<InsightInterpretationUpdateInput, InsightInterpretationUncheckedUpdateInput>
    /**
     * Choose, which InsightInterpretation to update.
     */
    where: InsightInterpretationWhereUniqueInput
  }

  /**
   * InsightInterpretation updateMany
   */
  export type InsightInterpretationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightInterpretations.
     */
    data: XOR<InsightInterpretationUpdateManyMutationInput, InsightInterpretationUncheckedUpdateManyInput>
    /**
     * Filter which InsightInterpretations to update
     */
    where?: InsightInterpretationWhereInput
    /**
     * Limit how many InsightInterpretations to update.
     */
    limit?: number
  }

  /**
   * InsightInterpretation updateManyAndReturn
   */
  export type InsightInterpretationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * The data used to update InsightInterpretations.
     */
    data: XOR<InsightInterpretationUpdateManyMutationInput, InsightInterpretationUncheckedUpdateManyInput>
    /**
     * Filter which InsightInterpretations to update
     */
    where?: InsightInterpretationWhereInput
    /**
     * Limit how many InsightInterpretations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightInterpretation upsert
   */
  export type InsightInterpretationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightInterpretation to update in case it exists.
     */
    where: InsightInterpretationWhereUniqueInput
    /**
     * In case the InsightInterpretation found by the `where` argument doesn't exist, create a new InsightInterpretation with this data.
     */
    create: XOR<InsightInterpretationCreateInput, InsightInterpretationUncheckedCreateInput>
    /**
     * In case the InsightInterpretation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightInterpretationUpdateInput, InsightInterpretationUncheckedUpdateInput>
  }

  /**
   * InsightInterpretation delete
   */
  export type InsightInterpretationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
    /**
     * Filter which InsightInterpretation to delete.
     */
    where: InsightInterpretationWhereUniqueInput
  }

  /**
   * InsightInterpretation deleteMany
   */
  export type InsightInterpretationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightInterpretations to delete
     */
    where?: InsightInterpretationWhereInput
    /**
     * Limit how many InsightInterpretations to delete.
     */
    limit?: number
  }

  /**
   * InsightInterpretation without action
   */
  export type InsightInterpretationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightInterpretation
     */
    select?: InsightInterpretationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightInterpretation
     */
    omit?: InsightInterpretationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInterpretationInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ReviewType | null
    periodKey: string | null
    periodStart: Date | null
    periodEnd: Date | null
    renderedMarkdown: string | null
    summary: string | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ReviewType | null
    periodKey: string | null
    periodStart: Date | null
    periodEnd: Date | null
    renderedMarkdown: string | null
    summary: string | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    periodKey: number
    periodStart: number
    periodEnd: number
    structuredContent: number
    renderedMarkdown: number
    summary: number
    eventIds: number
    interpretationIds: number
    patternIds: number
    insightIds: number
    priorReviewIds: number
    createdAt: number
    _all: number
  }


  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    periodKey?: true
    periodStart?: true
    periodEnd?: true
    renderedMarkdown?: true
    summary?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    periodKey?: true
    periodStart?: true
    periodEnd?: true
    renderedMarkdown?: true
    summary?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    periodKey?: true
    periodStart?: true
    periodEnd?: true
    structuredContent?: true
    renderedMarkdown?: true
    summary?: true
    eventIds?: true
    interpretationIds?: true
    patternIds?: true
    insightIds?: true
    priorReviewIds?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ReviewType
    periodKey: string
    periodStart: Date
    periodEnd: Date
    structuredContent: JsonValue
    renderedMarkdown: string
    summary: string
    eventIds: string[]
    interpretationIds: string[]
    patternIds: string[]
    insightIds: string[]
    priorReviewIds: string[]
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    periodKey?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    structuredContent?: boolean
    renderedMarkdown?: boolean
    summary?: boolean
    eventIds?: boolean
    interpretationIds?: boolean
    patternIds?: boolean
    insightIds?: boolean
    priorReviewIds?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    periodKey?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    structuredContent?: boolean
    renderedMarkdown?: boolean
    summary?: boolean
    eventIds?: boolean
    interpretationIds?: boolean
    patternIds?: boolean
    insightIds?: boolean
    priorReviewIds?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    periodKey?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    structuredContent?: boolean
    renderedMarkdown?: boolean
    summary?: boolean
    eventIds?: boolean
    interpretationIds?: boolean
    patternIds?: boolean
    insightIds?: boolean
    priorReviewIds?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    periodKey?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    structuredContent?: boolean
    renderedMarkdown?: boolean
    summary?: boolean
    eventIds?: boolean
    interpretationIds?: boolean
    patternIds?: boolean
    insightIds?: boolean
    priorReviewIds?: boolean
    createdAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "periodKey" | "periodStart" | "periodEnd" | "structuredContent" | "renderedMarkdown" | "summary" | "eventIds" | "interpretationIds" | "patternIds" | "insightIds" | "priorReviewIds" | "createdAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ReviewType
      periodKey: string
      periodStart: Date
      periodEnd: Date
      structuredContent: Prisma.JsonValue
      renderedMarkdown: string
      summary: string
      eventIds: string[]
      interpretationIds: string[]
      patternIds: string[]
      insightIds: string[]
      priorReviewIds: string[]
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly type: FieldRef<"Review", 'ReviewType'>
    readonly periodKey: FieldRef<"Review", 'String'>
    readonly periodStart: FieldRef<"Review", 'DateTime'>
    readonly periodEnd: FieldRef<"Review", 'DateTime'>
    readonly structuredContent: FieldRef<"Review", 'Json'>
    readonly renderedMarkdown: FieldRef<"Review", 'String'>
    readonly summary: FieldRef<"Review", 'String'>
    readonly eventIds: FieldRef<"Review", 'String[]'>
    readonly interpretationIds: FieldRef<"Review", 'String[]'>
    readonly patternIds: FieldRef<"Review", 'String[]'>
    readonly insightIds: FieldRef<"Review", 'String[]'>
    readonly priorReviewIds: FieldRef<"Review", 'String[]'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    timezone: 'timezone',
    baseline: 'baseline',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    audioRef: 'audioRef',
    occurredAt: 'occurredAt',
    createdAt: 'createdAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const InterpretationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventId: 'eventId',
    content: 'content',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type InterpretationScalarFieldEnum = (typeof InterpretationScalarFieldEnum)[keyof typeof InterpretationScalarFieldEnum]


  export const PatternScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    description: 'description',
    firstDetectedAt: 'firstDetectedAt',
    lastReinforcedAt: 'lastReinforcedAt',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type PatternScalarFieldEnum = (typeof PatternScalarFieldEnum)[keyof typeof PatternScalarFieldEnum]


  export const PatternEventScalarFieldEnum: {
    id: 'id',
    patternId: 'patternId',
    eventId: 'eventId',
    addedAt: 'addedAt'
  };

  export type PatternEventScalarFieldEnum = (typeof PatternEventScalarFieldEnum)[keyof typeof PatternEventScalarFieldEnum]


  export const InsightScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    statement: 'statement',
    explanation: 'explanation',
    confidence: 'confidence',
    status: 'status',
    category: 'category',
    temporalScope: 'temporalScope',
    supersededById: 'supersededById',
    supersedes: 'supersedes',
    triggerType: 'triggerType',
    triggerEventId: 'triggerEventId',
    firstDetectedAt: 'firstDetectedAt',
    lastReinforcedAt: 'lastReinforcedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsightScalarFieldEnum = (typeof InsightScalarFieldEnum)[keyof typeof InsightScalarFieldEnum]


  export const InsightEventScalarFieldEnum: {
    id: 'id',
    insightId: 'insightId',
    eventId: 'eventId',
    relevance: 'relevance',
    excerpt: 'excerpt',
    addedAt: 'addedAt'
  };

  export type InsightEventScalarFieldEnum = (typeof InsightEventScalarFieldEnum)[keyof typeof InsightEventScalarFieldEnum]


  export const InsightPatternScalarFieldEnum: {
    id: 'id',
    insightId: 'insightId',
    patternId: 'patternId',
    relevance: 'relevance',
    excerpt: 'excerpt',
    addedAt: 'addedAt'
  };

  export type InsightPatternScalarFieldEnum = (typeof InsightPatternScalarFieldEnum)[keyof typeof InsightPatternScalarFieldEnum]


  export const InsightInterpretationScalarFieldEnum: {
    id: 'id',
    insightId: 'insightId',
    interpretationId: 'interpretationId',
    relevance: 'relevance',
    excerpt: 'excerpt',
    addedAt: 'addedAt'
  };

  export type InsightInterpretationScalarFieldEnum = (typeof InsightInterpretationScalarFieldEnum)[keyof typeof InsightInterpretationScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    periodKey: 'periodKey',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    structuredContent: 'structuredContent',
    renderedMarkdown: 'renderedMarkdown',
    summary: 'summary',
    eventIds: 'eventIds',
    interpretationIds: 'interpretationIds',
    patternIds: 'patternIds',
    insightIds: 'insightIds',
    priorReviewIds: 'priorReviewIds',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'InterpretationSource'
   */
  export type EnumInterpretationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterpretationSource'>
    


  /**
   * Reference to a field of type 'InterpretationSource[]'
   */
  export type ListEnumInterpretationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterpretationSource[]'>
    


  /**
   * Reference to a field of type 'PatternStatus'
   */
  export type EnumPatternStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatternStatus'>
    


  /**
   * Reference to a field of type 'PatternStatus[]'
   */
  export type ListEnumPatternStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatternStatus[]'>
    


  /**
   * Reference to a field of type 'ConfidenceLevel'
   */
  export type EnumConfidenceLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfidenceLevel'>
    


  /**
   * Reference to a field of type 'ConfidenceLevel[]'
   */
  export type ListEnumConfidenceLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfidenceLevel[]'>
    


  /**
   * Reference to a field of type 'InsightStatus'
   */
  export type EnumInsightStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightStatus'>
    


  /**
   * Reference to a field of type 'InsightStatus[]'
   */
  export type ListEnumInsightStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightStatus[]'>
    


  /**
   * Reference to a field of type 'EvidenceRelevance'
   */
  export type EnumEvidenceRelevanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceRelevance'>
    


  /**
   * Reference to a field of type 'EvidenceRelevance[]'
   */
  export type ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceRelevance[]'>
    


  /**
   * Reference to a field of type 'ReviewType'
   */
  export type EnumReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewType'>
    


  /**
   * Reference to a field of type 'ReviewType[]'
   */
  export type ListEnumReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    baseline?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    events?: EventListRelationFilter
    interpretations?: InterpretationListRelationFilter
    patterns?: PatternListRelationFilter
    insights?: InsightListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    timezone?: SortOrder
    baseline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    events?: EventOrderByRelationAggregateInput
    interpretations?: InterpretationOrderByRelationAggregateInput
    patterns?: PatternOrderByRelationAggregateInput
    insights?: InsightOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    baseline?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    events?: EventListRelationFilter
    interpretations?: InterpretationListRelationFilter
    patterns?: PatternListRelationFilter
    insights?: InsightListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    timezone?: SortOrder
    baseline?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    baseline?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    userId?: StringFilter<"Event"> | string
    content?: StringFilter<"Event"> | string
    audioRef?: StringNullableFilter<"Event"> | string | null
    occurredAt?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interpretation?: XOR<InterpretationNullableScalarRelationFilter, InterpretationWhereInput> | null
    patternEvents?: PatternEventListRelationFilter
    insightEvents?: InsightEventListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    audioRef?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    interpretation?: InterpretationOrderByWithRelationInput
    patternEvents?: PatternEventOrderByRelationAggregateInput
    insightEvents?: InsightEventOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    userId?: StringFilter<"Event"> | string
    content?: StringFilter<"Event"> | string
    audioRef?: StringNullableFilter<"Event"> | string | null
    occurredAt?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interpretation?: XOR<InterpretationNullableScalarRelationFilter, InterpretationWhereInput> | null
    patternEvents?: PatternEventListRelationFilter
    insightEvents?: InsightEventListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    audioRef?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    userId?: StringWithAggregatesFilter<"Event"> | string
    content?: StringWithAggregatesFilter<"Event"> | string
    audioRef?: StringNullableWithAggregatesFilter<"Event"> | string | null
    occurredAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type InterpretationWhereInput = {
    AND?: InterpretationWhereInput | InterpretationWhereInput[]
    OR?: InterpretationWhereInput[]
    NOT?: InterpretationWhereInput | InterpretationWhereInput[]
    id?: StringFilter<"Interpretation"> | string
    userId?: StringFilter<"Interpretation"> | string
    eventId?: StringFilter<"Interpretation"> | string
    content?: StringFilter<"Interpretation"> | string
    source?: EnumInterpretationSourceFilter<"Interpretation"> | $Enums.InterpretationSource
    createdAt?: DateTimeFilter<"Interpretation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    insightInterpretations?: InsightInterpretationListRelationFilter
  }

  export type InterpretationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    insightInterpretations?: InsightInterpretationOrderByRelationAggregateInput
  }

  export type InterpretationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId?: string
    AND?: InterpretationWhereInput | InterpretationWhereInput[]
    OR?: InterpretationWhereInput[]
    NOT?: InterpretationWhereInput | InterpretationWhereInput[]
    userId?: StringFilter<"Interpretation"> | string
    content?: StringFilter<"Interpretation"> | string
    source?: EnumInterpretationSourceFilter<"Interpretation"> | $Enums.InterpretationSource
    createdAt?: DateTimeFilter<"Interpretation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    insightInterpretations?: InsightInterpretationListRelationFilter
  }, "id" | "eventId">

  export type InterpretationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    _count?: InterpretationCountOrderByAggregateInput
    _max?: InterpretationMaxOrderByAggregateInput
    _min?: InterpretationMinOrderByAggregateInput
  }

  export type InterpretationScalarWhereWithAggregatesInput = {
    AND?: InterpretationScalarWhereWithAggregatesInput | InterpretationScalarWhereWithAggregatesInput[]
    OR?: InterpretationScalarWhereWithAggregatesInput[]
    NOT?: InterpretationScalarWhereWithAggregatesInput | InterpretationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interpretation"> | string
    userId?: StringWithAggregatesFilter<"Interpretation"> | string
    eventId?: StringWithAggregatesFilter<"Interpretation"> | string
    content?: StringWithAggregatesFilter<"Interpretation"> | string
    source?: EnumInterpretationSourceWithAggregatesFilter<"Interpretation"> | $Enums.InterpretationSource
    createdAt?: DateTimeWithAggregatesFilter<"Interpretation"> | Date | string
  }

  export type PatternWhereInput = {
    AND?: PatternWhereInput | PatternWhereInput[]
    OR?: PatternWhereInput[]
    NOT?: PatternWhereInput | PatternWhereInput[]
    id?: StringFilter<"Pattern"> | string
    userId?: StringFilter<"Pattern"> | string
    description?: StringFilter<"Pattern"> | string
    firstDetectedAt?: DateTimeFilter<"Pattern"> | Date | string
    lastReinforcedAt?: DateTimeFilter<"Pattern"> | Date | string
    status?: EnumPatternStatusFilter<"Pattern"> | $Enums.PatternStatus
    createdAt?: DateTimeFilter<"Pattern"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    patternEvents?: PatternEventListRelationFilter
    insightPatterns?: InsightPatternListRelationFilter
  }

  export type PatternOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    patternEvents?: PatternEventOrderByRelationAggregateInput
    insightPatterns?: InsightPatternOrderByRelationAggregateInput
  }

  export type PatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatternWhereInput | PatternWhereInput[]
    OR?: PatternWhereInput[]
    NOT?: PatternWhereInput | PatternWhereInput[]
    userId?: StringFilter<"Pattern"> | string
    description?: StringFilter<"Pattern"> | string
    firstDetectedAt?: DateTimeFilter<"Pattern"> | Date | string
    lastReinforcedAt?: DateTimeFilter<"Pattern"> | Date | string
    status?: EnumPatternStatusFilter<"Pattern"> | $Enums.PatternStatus
    createdAt?: DateTimeFilter<"Pattern"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    patternEvents?: PatternEventListRelationFilter
    insightPatterns?: InsightPatternListRelationFilter
  }, "id">

  export type PatternOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: PatternCountOrderByAggregateInput
    _max?: PatternMaxOrderByAggregateInput
    _min?: PatternMinOrderByAggregateInput
  }

  export type PatternScalarWhereWithAggregatesInput = {
    AND?: PatternScalarWhereWithAggregatesInput | PatternScalarWhereWithAggregatesInput[]
    OR?: PatternScalarWhereWithAggregatesInput[]
    NOT?: PatternScalarWhereWithAggregatesInput | PatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pattern"> | string
    userId?: StringWithAggregatesFilter<"Pattern"> | string
    description?: StringWithAggregatesFilter<"Pattern"> | string
    firstDetectedAt?: DateTimeWithAggregatesFilter<"Pattern"> | Date | string
    lastReinforcedAt?: DateTimeWithAggregatesFilter<"Pattern"> | Date | string
    status?: EnumPatternStatusWithAggregatesFilter<"Pattern"> | $Enums.PatternStatus
    createdAt?: DateTimeWithAggregatesFilter<"Pattern"> | Date | string
  }

  export type PatternEventWhereInput = {
    AND?: PatternEventWhereInput | PatternEventWhereInput[]
    OR?: PatternEventWhereInput[]
    NOT?: PatternEventWhereInput | PatternEventWhereInput[]
    id?: StringFilter<"PatternEvent"> | string
    patternId?: StringFilter<"PatternEvent"> | string
    eventId?: StringFilter<"PatternEvent"> | string
    addedAt?: DateTimeFilter<"PatternEvent"> | Date | string
    pattern?: XOR<PatternScalarRelationFilter, PatternWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type PatternEventOrderByWithRelationInput = {
    id?: SortOrder
    patternId?: SortOrder
    eventId?: SortOrder
    addedAt?: SortOrder
    pattern?: PatternOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
  }

  export type PatternEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patternId_eventId?: PatternEventPatternIdEventIdCompoundUniqueInput
    AND?: PatternEventWhereInput | PatternEventWhereInput[]
    OR?: PatternEventWhereInput[]
    NOT?: PatternEventWhereInput | PatternEventWhereInput[]
    patternId?: StringFilter<"PatternEvent"> | string
    eventId?: StringFilter<"PatternEvent"> | string
    addedAt?: DateTimeFilter<"PatternEvent"> | Date | string
    pattern?: XOR<PatternScalarRelationFilter, PatternWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id" | "patternId_eventId">

  export type PatternEventOrderByWithAggregationInput = {
    id?: SortOrder
    patternId?: SortOrder
    eventId?: SortOrder
    addedAt?: SortOrder
    _count?: PatternEventCountOrderByAggregateInput
    _max?: PatternEventMaxOrderByAggregateInput
    _min?: PatternEventMinOrderByAggregateInput
  }

  export type PatternEventScalarWhereWithAggregatesInput = {
    AND?: PatternEventScalarWhereWithAggregatesInput | PatternEventScalarWhereWithAggregatesInput[]
    OR?: PatternEventScalarWhereWithAggregatesInput[]
    NOT?: PatternEventScalarWhereWithAggregatesInput | PatternEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatternEvent"> | string
    patternId?: StringWithAggregatesFilter<"PatternEvent"> | string
    eventId?: StringWithAggregatesFilter<"PatternEvent"> | string
    addedAt?: DateTimeWithAggregatesFilter<"PatternEvent"> | Date | string
  }

  export type InsightWhereInput = {
    AND?: InsightWhereInput | InsightWhereInput[]
    OR?: InsightWhereInput[]
    NOT?: InsightWhereInput | InsightWhereInput[]
    id?: StringFilter<"Insight"> | string
    userId?: StringFilter<"Insight"> | string
    statement?: StringFilter<"Insight"> | string
    explanation?: StringFilter<"Insight"> | string
    confidence?: EnumConfidenceLevelFilter<"Insight"> | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFilter<"Insight"> | $Enums.InsightStatus
    category?: StringNullableFilter<"Insight"> | string | null
    temporalScope?: StringNullableFilter<"Insight"> | string | null
    supersededById?: StringNullableFilter<"Insight"> | string | null
    supersedes?: StringNullableFilter<"Insight"> | string | null
    triggerType?: StringNullableFilter<"Insight"> | string | null
    triggerEventId?: StringNullableFilter<"Insight"> | string | null
    firstDetectedAt?: DateTimeFilter<"Insight"> | Date | string
    lastReinforcedAt?: DateTimeFilter<"Insight"> | Date | string
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    updatedAt?: DateTimeFilter<"Insight"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    insightEvents?: InsightEventListRelationFilter
    insightPatterns?: InsightPatternListRelationFilter
    insightInterpretations?: InsightInterpretationListRelationFilter
  }

  export type InsightOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    statement?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    temporalScope?: SortOrderInput | SortOrder
    supersededById?: SortOrderInput | SortOrder
    supersedes?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerEventId?: SortOrderInput | SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    insightEvents?: InsightEventOrderByRelationAggregateInput
    insightPatterns?: InsightPatternOrderByRelationAggregateInput
    insightInterpretations?: InsightInterpretationOrderByRelationAggregateInput
  }

  export type InsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsightWhereInput | InsightWhereInput[]
    OR?: InsightWhereInput[]
    NOT?: InsightWhereInput | InsightWhereInput[]
    userId?: StringFilter<"Insight"> | string
    statement?: StringFilter<"Insight"> | string
    explanation?: StringFilter<"Insight"> | string
    confidence?: EnumConfidenceLevelFilter<"Insight"> | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFilter<"Insight"> | $Enums.InsightStatus
    category?: StringNullableFilter<"Insight"> | string | null
    temporalScope?: StringNullableFilter<"Insight"> | string | null
    supersededById?: StringNullableFilter<"Insight"> | string | null
    supersedes?: StringNullableFilter<"Insight"> | string | null
    triggerType?: StringNullableFilter<"Insight"> | string | null
    triggerEventId?: StringNullableFilter<"Insight"> | string | null
    firstDetectedAt?: DateTimeFilter<"Insight"> | Date | string
    lastReinforcedAt?: DateTimeFilter<"Insight"> | Date | string
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    updatedAt?: DateTimeFilter<"Insight"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    insightEvents?: InsightEventListRelationFilter
    insightPatterns?: InsightPatternListRelationFilter
    insightInterpretations?: InsightInterpretationListRelationFilter
  }, "id">

  export type InsightOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    statement?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    temporalScope?: SortOrderInput | SortOrder
    supersededById?: SortOrderInput | SortOrder
    supersedes?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerEventId?: SortOrderInput | SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsightCountOrderByAggregateInput
    _max?: InsightMaxOrderByAggregateInput
    _min?: InsightMinOrderByAggregateInput
  }

  export type InsightScalarWhereWithAggregatesInput = {
    AND?: InsightScalarWhereWithAggregatesInput | InsightScalarWhereWithAggregatesInput[]
    OR?: InsightScalarWhereWithAggregatesInput[]
    NOT?: InsightScalarWhereWithAggregatesInput | InsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Insight"> | string
    userId?: StringWithAggregatesFilter<"Insight"> | string
    statement?: StringWithAggregatesFilter<"Insight"> | string
    explanation?: StringWithAggregatesFilter<"Insight"> | string
    confidence?: EnumConfidenceLevelWithAggregatesFilter<"Insight"> | $Enums.ConfidenceLevel
    status?: EnumInsightStatusWithAggregatesFilter<"Insight"> | $Enums.InsightStatus
    category?: StringNullableWithAggregatesFilter<"Insight"> | string | null
    temporalScope?: StringNullableWithAggregatesFilter<"Insight"> | string | null
    supersededById?: StringNullableWithAggregatesFilter<"Insight"> | string | null
    supersedes?: StringNullableWithAggregatesFilter<"Insight"> | string | null
    triggerType?: StringNullableWithAggregatesFilter<"Insight"> | string | null
    triggerEventId?: StringNullableWithAggregatesFilter<"Insight"> | string | null
    firstDetectedAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
    lastReinforcedAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
  }

  export type InsightEventWhereInput = {
    AND?: InsightEventWhereInput | InsightEventWhereInput[]
    OR?: InsightEventWhereInput[]
    NOT?: InsightEventWhereInput | InsightEventWhereInput[]
    id?: StringFilter<"InsightEvent"> | string
    insightId?: StringFilter<"InsightEvent"> | string
    eventId?: StringFilter<"InsightEvent"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightEvent"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightEvent"> | string | null
    addedAt?: DateTimeFilter<"InsightEvent"> | Date | string
    insight?: XOR<InsightScalarRelationFilter, InsightWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type InsightEventOrderByWithRelationInput = {
    id?: SortOrder
    insightId?: SortOrder
    eventId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    insight?: InsightOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
  }

  export type InsightEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    insightId_eventId?: InsightEventInsightIdEventIdCompoundUniqueInput
    AND?: InsightEventWhereInput | InsightEventWhereInput[]
    OR?: InsightEventWhereInput[]
    NOT?: InsightEventWhereInput | InsightEventWhereInput[]
    insightId?: StringFilter<"InsightEvent"> | string
    eventId?: StringFilter<"InsightEvent"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightEvent"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightEvent"> | string | null
    addedAt?: DateTimeFilter<"InsightEvent"> | Date | string
    insight?: XOR<InsightScalarRelationFilter, InsightWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id" | "insightId_eventId">

  export type InsightEventOrderByWithAggregationInput = {
    id?: SortOrder
    insightId?: SortOrder
    eventId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: InsightEventCountOrderByAggregateInput
    _max?: InsightEventMaxOrderByAggregateInput
    _min?: InsightEventMinOrderByAggregateInput
  }

  export type InsightEventScalarWhereWithAggregatesInput = {
    AND?: InsightEventScalarWhereWithAggregatesInput | InsightEventScalarWhereWithAggregatesInput[]
    OR?: InsightEventScalarWhereWithAggregatesInput[]
    NOT?: InsightEventScalarWhereWithAggregatesInput | InsightEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsightEvent"> | string
    insightId?: StringWithAggregatesFilter<"InsightEvent"> | string
    eventId?: StringWithAggregatesFilter<"InsightEvent"> | string
    relevance?: EnumEvidenceRelevanceWithAggregatesFilter<"InsightEvent"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableWithAggregatesFilter<"InsightEvent"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"InsightEvent"> | Date | string
  }

  export type InsightPatternWhereInput = {
    AND?: InsightPatternWhereInput | InsightPatternWhereInput[]
    OR?: InsightPatternWhereInput[]
    NOT?: InsightPatternWhereInput | InsightPatternWhereInput[]
    id?: StringFilter<"InsightPattern"> | string
    insightId?: StringFilter<"InsightPattern"> | string
    patternId?: StringFilter<"InsightPattern"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightPattern"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightPattern"> | string | null
    addedAt?: DateTimeFilter<"InsightPattern"> | Date | string
    insight?: XOR<InsightScalarRelationFilter, InsightWhereInput>
    pattern?: XOR<PatternScalarRelationFilter, PatternWhereInput>
  }

  export type InsightPatternOrderByWithRelationInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    insight?: InsightOrderByWithRelationInput
    pattern?: PatternOrderByWithRelationInput
  }

  export type InsightPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    insightId_patternId?: InsightPatternInsightIdPatternIdCompoundUniqueInput
    AND?: InsightPatternWhereInput | InsightPatternWhereInput[]
    OR?: InsightPatternWhereInput[]
    NOT?: InsightPatternWhereInput | InsightPatternWhereInput[]
    insightId?: StringFilter<"InsightPattern"> | string
    patternId?: StringFilter<"InsightPattern"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightPattern"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightPattern"> | string | null
    addedAt?: DateTimeFilter<"InsightPattern"> | Date | string
    insight?: XOR<InsightScalarRelationFilter, InsightWhereInput>
    pattern?: XOR<PatternScalarRelationFilter, PatternWhereInput>
  }, "id" | "insightId_patternId">

  export type InsightPatternOrderByWithAggregationInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: InsightPatternCountOrderByAggregateInput
    _max?: InsightPatternMaxOrderByAggregateInput
    _min?: InsightPatternMinOrderByAggregateInput
  }

  export type InsightPatternScalarWhereWithAggregatesInput = {
    AND?: InsightPatternScalarWhereWithAggregatesInput | InsightPatternScalarWhereWithAggregatesInput[]
    OR?: InsightPatternScalarWhereWithAggregatesInput[]
    NOT?: InsightPatternScalarWhereWithAggregatesInput | InsightPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsightPattern"> | string
    insightId?: StringWithAggregatesFilter<"InsightPattern"> | string
    patternId?: StringWithAggregatesFilter<"InsightPattern"> | string
    relevance?: EnumEvidenceRelevanceWithAggregatesFilter<"InsightPattern"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableWithAggregatesFilter<"InsightPattern"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"InsightPattern"> | Date | string
  }

  export type InsightInterpretationWhereInput = {
    AND?: InsightInterpretationWhereInput | InsightInterpretationWhereInput[]
    OR?: InsightInterpretationWhereInput[]
    NOT?: InsightInterpretationWhereInput | InsightInterpretationWhereInput[]
    id?: StringFilter<"InsightInterpretation"> | string
    insightId?: StringFilter<"InsightInterpretation"> | string
    interpretationId?: StringFilter<"InsightInterpretation"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightInterpretation"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightInterpretation"> | string | null
    addedAt?: DateTimeFilter<"InsightInterpretation"> | Date | string
    insight?: XOR<InsightScalarRelationFilter, InsightWhereInput>
    interpretation?: XOR<InterpretationScalarRelationFilter, InterpretationWhereInput>
  }

  export type InsightInterpretationOrderByWithRelationInput = {
    id?: SortOrder
    insightId?: SortOrder
    interpretationId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    insight?: InsightOrderByWithRelationInput
    interpretation?: InterpretationOrderByWithRelationInput
  }

  export type InsightInterpretationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    insightId_interpretationId?: InsightInterpretationInsightIdInterpretationIdCompoundUniqueInput
    AND?: InsightInterpretationWhereInput | InsightInterpretationWhereInput[]
    OR?: InsightInterpretationWhereInput[]
    NOT?: InsightInterpretationWhereInput | InsightInterpretationWhereInput[]
    insightId?: StringFilter<"InsightInterpretation"> | string
    interpretationId?: StringFilter<"InsightInterpretation"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightInterpretation"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightInterpretation"> | string | null
    addedAt?: DateTimeFilter<"InsightInterpretation"> | Date | string
    insight?: XOR<InsightScalarRelationFilter, InsightWhereInput>
    interpretation?: XOR<InterpretationScalarRelationFilter, InterpretationWhereInput>
  }, "id" | "insightId_interpretationId">

  export type InsightInterpretationOrderByWithAggregationInput = {
    id?: SortOrder
    insightId?: SortOrder
    interpretationId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: InsightInterpretationCountOrderByAggregateInput
    _max?: InsightInterpretationMaxOrderByAggregateInput
    _min?: InsightInterpretationMinOrderByAggregateInput
  }

  export type InsightInterpretationScalarWhereWithAggregatesInput = {
    AND?: InsightInterpretationScalarWhereWithAggregatesInput | InsightInterpretationScalarWhereWithAggregatesInput[]
    OR?: InsightInterpretationScalarWhereWithAggregatesInput[]
    NOT?: InsightInterpretationScalarWhereWithAggregatesInput | InsightInterpretationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsightInterpretation"> | string
    insightId?: StringWithAggregatesFilter<"InsightInterpretation"> | string
    interpretationId?: StringWithAggregatesFilter<"InsightInterpretation"> | string
    relevance?: EnumEvidenceRelevanceWithAggregatesFilter<"InsightInterpretation"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableWithAggregatesFilter<"InsightInterpretation"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"InsightInterpretation"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    type?: EnumReviewTypeFilter<"Review"> | $Enums.ReviewType
    periodKey?: StringFilter<"Review"> | string
    periodStart?: DateTimeFilter<"Review"> | Date | string
    periodEnd?: DateTimeFilter<"Review"> | Date | string
    structuredContent?: JsonFilter<"Review">
    renderedMarkdown?: StringFilter<"Review"> | string
    summary?: StringFilter<"Review"> | string
    eventIds?: StringNullableListFilter<"Review">
    interpretationIds?: StringNullableListFilter<"Review">
    patternIds?: StringNullableListFilter<"Review">
    insightIds?: StringNullableListFilter<"Review">
    priorReviewIds?: StringNullableListFilter<"Review">
    createdAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    periodKey?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    structuredContent?: SortOrder
    renderedMarkdown?: SortOrder
    summary?: SortOrder
    eventIds?: SortOrder
    interpretationIds?: SortOrder
    patternIds?: SortOrder
    insightIds?: SortOrder
    priorReviewIds?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_type_periodKey?: ReviewUserIdTypePeriodKeyCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    type?: EnumReviewTypeFilter<"Review"> | $Enums.ReviewType
    periodKey?: StringFilter<"Review"> | string
    periodStart?: DateTimeFilter<"Review"> | Date | string
    periodEnd?: DateTimeFilter<"Review"> | Date | string
    structuredContent?: JsonFilter<"Review">
    renderedMarkdown?: StringFilter<"Review"> | string
    summary?: StringFilter<"Review"> | string
    eventIds?: StringNullableListFilter<"Review">
    interpretationIds?: StringNullableListFilter<"Review">
    patternIds?: StringNullableListFilter<"Review">
    insightIds?: StringNullableListFilter<"Review">
    priorReviewIds?: StringNullableListFilter<"Review">
    createdAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_type_periodKey">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    periodKey?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    structuredContent?: SortOrder
    renderedMarkdown?: SortOrder
    summary?: SortOrder
    eventIds?: SortOrder
    interpretationIds?: SortOrder
    patternIds?: SortOrder
    insightIds?: SortOrder
    priorReviewIds?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    type?: EnumReviewTypeWithAggregatesFilter<"Review"> | $Enums.ReviewType
    periodKey?: StringWithAggregatesFilter<"Review"> | string
    periodStart?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    structuredContent?: JsonWithAggregatesFilter<"Review">
    renderedMarkdown?: StringWithAggregatesFilter<"Review"> | string
    summary?: StringWithAggregatesFilter<"Review"> | string
    eventIds?: StringNullableListFilter<"Review">
    interpretationIds?: StringNullableListFilter<"Review">
    patternIds?: StringNullableListFilter<"Review">
    insightIds?: StringNullableListFilter<"Review">
    priorReviewIds?: StringNullableListFilter<"Review">
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutUserInput
    interpretations?: InterpretationCreateNestedManyWithoutUserInput
    patterns?: PatternCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    interpretations?: InterpretationUncheckedCreateNestedManyWithoutUserInput
    patterns?: PatternUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUpdateManyWithoutUserNestedInput
    patterns?: PatternUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUncheckedUpdateManyWithoutUserNestedInput
    patterns?: PatternUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEventsInput
    interpretation?: InterpretationCreateNestedOneWithoutEventInput
    patternEvents?: PatternEventCreateNestedManyWithoutEventInput
    insightEvents?: InsightEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    userId: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    interpretation?: InterpretationUncheckedCreateNestedOneWithoutEventInput
    patternEvents?: PatternEventUncheckedCreateNestedManyWithoutEventInput
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    interpretation?: InterpretationUpdateOneWithoutEventNestedInput
    patternEvents?: PatternEventUpdateManyWithoutEventNestedInput
    insightEvents?: InsightEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretation?: InterpretationUncheckedUpdateOneWithoutEventNestedInput
    patternEvents?: PatternEventUncheckedUpdateManyWithoutEventNestedInput
    insightEvents?: InsightEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    userId: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterpretationCreateInput = {
    id?: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterpretationsInput
    event: EventCreateNestedOneWithoutInterpretationInput
    insightInterpretations?: InsightInterpretationCreateNestedManyWithoutInterpretationInput
  }

  export type InterpretationUncheckedCreateInput = {
    id?: string
    userId: string
    eventId: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
    insightInterpretations?: InsightInterpretationUncheckedCreateNestedManyWithoutInterpretationInput
  }

  export type InterpretationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterpretationsNestedInput
    event?: EventUpdateOneRequiredWithoutInterpretationNestedInput
    insightInterpretations?: InsightInterpretationUpdateManyWithoutInterpretationNestedInput
  }

  export type InterpretationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightInterpretations?: InsightInterpretationUncheckedUpdateManyWithoutInterpretationNestedInput
  }

  export type InterpretationCreateManyInput = {
    id?: string
    userId: string
    eventId: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
  }

  export type InterpretationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterpretationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternCreateInput = {
    id?: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPatternsInput
    patternEvents?: PatternEventCreateNestedManyWithoutPatternInput
    insightPatterns?: InsightPatternCreateNestedManyWithoutPatternInput
  }

  export type PatternUncheckedCreateInput = {
    id?: string
    userId: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    patternEvents?: PatternEventUncheckedCreateNestedManyWithoutPatternInput
    insightPatterns?: InsightPatternUncheckedCreateNestedManyWithoutPatternInput
  }

  export type PatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatternsNestedInput
    patternEvents?: PatternEventUpdateManyWithoutPatternNestedInput
    insightPatterns?: InsightPatternUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patternEvents?: PatternEventUncheckedUpdateManyWithoutPatternNestedInput
    insightPatterns?: InsightPatternUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type PatternCreateManyInput = {
    id?: string
    userId: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
  }

  export type PatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternEventCreateInput = {
    id?: string
    addedAt?: Date | string
    pattern: PatternCreateNestedOneWithoutPatternEventsInput
    event: EventCreateNestedOneWithoutPatternEventsInput
  }

  export type PatternEventUncheckedCreateInput = {
    id?: string
    patternId: string
    eventId: string
    addedAt?: Date | string
  }

  export type PatternEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: PatternUpdateOneRequiredWithoutPatternEventsNestedInput
    event?: EventUpdateOneRequiredWithoutPatternEventsNestedInput
  }

  export type PatternEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternEventCreateManyInput = {
    id?: string
    patternId: string
    eventId: string
    addedAt?: Date | string
  }

  export type PatternEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightCreateInput = {
    id?: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    insightEvents?: InsightEventCreateNestedManyWithoutInsightInput
    insightPatterns?: InsightPatternCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateInput = {
    id?: string
    userId: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutInsightInput
    insightPatterns?: InsightPatternUncheckedCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    insightEvents?: InsightEventUpdateManyWithoutInsightNestedInput
    insightPatterns?: InsightPatternUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightEvents?: InsightEventUncheckedUpdateManyWithoutInsightNestedInput
    insightPatterns?: InsightPatternUncheckedUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type InsightCreateManyInput = {
    id?: string
    userId: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightEventCreateInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    insight: InsightCreateNestedOneWithoutInsightEventsInput
    event: EventCreateNestedOneWithoutInsightEventsInput
  }

  export type InsightEventUncheckedCreateInput = {
    id?: string
    insightId: string
    eventId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutInsightEventsNestedInput
    event?: EventUpdateOneRequiredWithoutInsightEventsNestedInput
  }

  export type InsightEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightEventCreateManyInput = {
    id?: string
    insightId: string
    eventId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternCreateInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    insight: InsightCreateNestedOneWithoutInsightPatternsInput
    pattern: PatternCreateNestedOneWithoutInsightPatternsInput
  }

  export type InsightPatternUncheckedCreateInput = {
    id?: string
    insightId: string
    patternId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutInsightPatternsNestedInput
    pattern?: PatternUpdateOneRequiredWithoutInsightPatternsNestedInput
  }

  export type InsightPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternCreateManyInput = {
    id?: string
    insightId: string
    patternId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightInterpretationCreateInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    insight: InsightCreateNestedOneWithoutInsightInterpretationsInput
    interpretation: InterpretationCreateNestedOneWithoutInsightInterpretationsInput
  }

  export type InsightInterpretationUncheckedCreateInput = {
    id?: string
    insightId: string
    interpretationId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightInterpretationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutInsightInterpretationsNestedInput
    interpretation?: InterpretationUpdateOneRequiredWithoutInsightInterpretationsNestedInput
  }

  export type InsightInterpretationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    interpretationId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightInterpretationCreateManyInput = {
    id?: string
    insightId: string
    interpretationId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightInterpretationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightInterpretationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    interpretationId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    type: $Enums.ReviewType
    periodKey: string
    periodStart: Date | string
    periodEnd: Date | string
    structuredContent: JsonNullValueInput | InputJsonValue
    renderedMarkdown: string
    summary: string
    eventIds?: ReviewCreateeventIdsInput | string[]
    interpretationIds?: ReviewCreateinterpretationIdsInput | string[]
    patternIds?: ReviewCreatepatternIdsInput | string[]
    insightIds?: ReviewCreateinsightIdsInput | string[]
    priorReviewIds?: ReviewCreatepriorReviewIdsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ReviewType
    periodKey: string
    periodStart: Date | string
    periodEnd: Date | string
    structuredContent: JsonNullValueInput | InputJsonValue
    renderedMarkdown: string
    summary: string
    eventIds?: ReviewCreateeventIdsInput | string[]
    interpretationIds?: ReviewCreateinterpretationIdsInput | string[]
    patternIds?: ReviewCreatepatternIdsInput | string[]
    insightIds?: ReviewCreateinsightIdsInput | string[]
    priorReviewIds?: ReviewCreatepriorReviewIdsInput | string[]
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    periodKey?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredContent?: JsonNullValueInput | InputJsonValue
    renderedMarkdown?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    eventIds?: ReviewUpdateeventIdsInput | string[]
    interpretationIds?: ReviewUpdateinterpretationIdsInput | string[]
    patternIds?: ReviewUpdatepatternIdsInput | string[]
    insightIds?: ReviewUpdateinsightIdsInput | string[]
    priorReviewIds?: ReviewUpdatepriorReviewIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    periodKey?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredContent?: JsonNullValueInput | InputJsonValue
    renderedMarkdown?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    eventIds?: ReviewUpdateeventIdsInput | string[]
    interpretationIds?: ReviewUpdateinterpretationIdsInput | string[]
    patternIds?: ReviewUpdatepatternIdsInput | string[]
    insightIds?: ReviewUpdateinsightIdsInput | string[]
    priorReviewIds?: ReviewUpdatepriorReviewIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ReviewType
    periodKey: string
    periodStart: Date | string
    periodEnd: Date | string
    structuredContent: JsonNullValueInput | InputJsonValue
    renderedMarkdown: string
    summary: string
    eventIds?: ReviewCreateeventIdsInput | string[]
    interpretationIds?: ReviewCreateinterpretationIdsInput | string[]
    patternIds?: ReviewCreatepatternIdsInput | string[]
    insightIds?: ReviewCreateinsightIdsInput | string[]
    priorReviewIds?: ReviewCreatepriorReviewIdsInput | string[]
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    periodKey?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredContent?: JsonNullValueInput | InputJsonValue
    renderedMarkdown?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    eventIds?: ReviewUpdateeventIdsInput | string[]
    interpretationIds?: ReviewUpdateinterpretationIdsInput | string[]
    patternIds?: ReviewUpdatepatternIdsInput | string[]
    insightIds?: ReviewUpdateinsightIdsInput | string[]
    priorReviewIds?: ReviewUpdatepriorReviewIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    periodKey?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredContent?: JsonNullValueInput | InputJsonValue
    renderedMarkdown?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    eventIds?: ReviewUpdateeventIdsInput | string[]
    interpretationIds?: ReviewUpdateinterpretationIdsInput | string[]
    patternIds?: ReviewUpdatepatternIdsInput | string[]
    insightIds?: ReviewUpdateinsightIdsInput | string[]
    priorReviewIds?: ReviewUpdatepriorReviewIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type InterpretationListRelationFilter = {
    every?: InterpretationWhereInput
    some?: InterpretationWhereInput
    none?: InterpretationWhereInput
  }

  export type PatternListRelationFilter = {
    every?: PatternWhereInput
    some?: PatternWhereInput
    none?: PatternWhereInput
  }

  export type InsightListRelationFilter = {
    every?: InsightWhereInput
    some?: InsightWhereInput
    none?: InsightWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterpretationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    timezone?: SortOrder
    baseline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    timezone?: SortOrder
    baseline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    timezone?: SortOrder
    baseline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InterpretationNullableScalarRelationFilter = {
    is?: InterpretationWhereInput | null
    isNot?: InterpretationWhereInput | null
  }

  export type PatternEventListRelationFilter = {
    every?: PatternEventWhereInput
    some?: PatternEventWhereInput
    none?: PatternEventWhereInput
  }

  export type InsightEventListRelationFilter = {
    every?: InsightEventWhereInput
    some?: InsightEventWhereInput
    none?: InsightEventWhereInput
  }

  export type PatternEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsightEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    audioRef?: SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    audioRef?: SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    audioRef?: SortOrder
    occurredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInterpretationSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.InterpretationSource | EnumInterpretationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInterpretationSourceFilter<$PrismaModel> | $Enums.InterpretationSource
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type InsightInterpretationListRelationFilter = {
    every?: InsightInterpretationWhereInput
    some?: InsightInterpretationWhereInput
    none?: InsightInterpretationWhereInput
  }

  export type InsightInterpretationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterpretationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type InterpretationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type InterpretationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInterpretationSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterpretationSource | EnumInterpretationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInterpretationSourceWithAggregatesFilter<$PrismaModel> | $Enums.InterpretationSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterpretationSourceFilter<$PrismaModel>
    _max?: NestedEnumInterpretationSourceFilter<$PrismaModel>
  }

  export type EnumPatternStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusFilter<$PrismaModel> | $Enums.PatternStatus
  }

  export type InsightPatternListRelationFilter = {
    every?: InsightPatternWhereInput
    some?: InsightPatternWhereInput
    none?: InsightPatternWhereInput
  }

  export type InsightPatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatternCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PatternMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PatternMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPatternStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusWithAggregatesFilter<$PrismaModel> | $Enums.PatternStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatternStatusFilter<$PrismaModel>
    _max?: NestedEnumPatternStatusFilter<$PrismaModel>
  }

  export type PatternScalarRelationFilter = {
    is?: PatternWhereInput
    isNot?: PatternWhereInput
  }

  export type PatternEventPatternIdEventIdCompoundUniqueInput = {
    patternId: string
    eventId: string
  }

  export type PatternEventCountOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    eventId?: SortOrder
    addedAt?: SortOrder
  }

  export type PatternEventMaxOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    eventId?: SortOrder
    addedAt?: SortOrder
  }

  export type PatternEventMinOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    eventId?: SortOrder
    addedAt?: SortOrder
  }

  export type EnumConfidenceLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfidenceLevel | EnumConfidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceLevelFilter<$PrismaModel> | $Enums.ConfidenceLevel
  }

  export type EnumInsightStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusFilter<$PrismaModel> | $Enums.InsightStatus
  }

  export type InsightCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statement?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    category?: SortOrder
    temporalScope?: SortOrder
    supersededById?: SortOrder
    supersedes?: SortOrder
    triggerType?: SortOrder
    triggerEventId?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsightMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statement?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    category?: SortOrder
    temporalScope?: SortOrder
    supersededById?: SortOrder
    supersedes?: SortOrder
    triggerType?: SortOrder
    triggerEventId?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsightMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statement?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    category?: SortOrder
    temporalScope?: SortOrder
    supersededById?: SortOrder
    supersedes?: SortOrder
    triggerType?: SortOrder
    triggerEventId?: SortOrder
    firstDetectedAt?: SortOrder
    lastReinforcedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConfidenceLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfidenceLevel | EnumConfidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceLevelWithAggregatesFilter<$PrismaModel> | $Enums.ConfidenceLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfidenceLevelFilter<$PrismaModel>
    _max?: NestedEnumConfidenceLevelFilter<$PrismaModel>
  }

  export type EnumInsightStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsightStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightStatusFilter<$PrismaModel>
    _max?: NestedEnumInsightStatusFilter<$PrismaModel>
  }

  export type EnumEvidenceRelevanceFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceRelevance | EnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceRelevanceFilter<$PrismaModel> | $Enums.EvidenceRelevance
  }

  export type InsightScalarRelationFilter = {
    is?: InsightWhereInput
    isNot?: InsightWhereInput
  }

  export type InsightEventInsightIdEventIdCompoundUniqueInput = {
    insightId: string
    eventId: string
  }

  export type InsightEventCountOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    eventId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type InsightEventMaxOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    eventId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type InsightEventMinOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    eventId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type EnumEvidenceRelevanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceRelevance | EnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceRelevanceWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceRelevance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceRelevanceFilter<$PrismaModel>
    _max?: NestedEnumEvidenceRelevanceFilter<$PrismaModel>
  }

  export type InsightPatternInsightIdPatternIdCompoundUniqueInput = {
    insightId: string
    patternId: string
  }

  export type InsightPatternCountOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type InsightPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type InsightPatternMinOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type InterpretationScalarRelationFilter = {
    is?: InterpretationWhereInput
    isNot?: InterpretationWhereInput
  }

  export type InsightInterpretationInsightIdInterpretationIdCompoundUniqueInput = {
    insightId: string
    interpretationId: string
  }

  export type InsightInterpretationCountOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    interpretationId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type InsightInterpretationMaxOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    interpretationId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type InsightInterpretationMinOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    interpretationId?: SortOrder
    relevance?: SortOrder
    excerpt?: SortOrder
    addedAt?: SortOrder
  }

  export type EnumReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeFilter<$PrismaModel> | $Enums.ReviewType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ReviewUserIdTypePeriodKeyCompoundUniqueInput = {
    userId: string
    type: $Enums.ReviewType
    periodKey: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    periodKey?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    structuredContent?: SortOrder
    renderedMarkdown?: SortOrder
    summary?: SortOrder
    eventIds?: SortOrder
    interpretationIds?: SortOrder
    patternIds?: SortOrder
    insightIds?: SortOrder
    priorReviewIds?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    periodKey?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    renderedMarkdown?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    periodKey?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    renderedMarkdown?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EventCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type InterpretationCreateNestedManyWithoutUserInput = {
    create?: XOR<InterpretationCreateWithoutUserInput, InterpretationUncheckedCreateWithoutUserInput> | InterpretationCreateWithoutUserInput[] | InterpretationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterpretationCreateOrConnectWithoutUserInput | InterpretationCreateOrConnectWithoutUserInput[]
    createMany?: InterpretationCreateManyUserInputEnvelope
    connect?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
  }

  export type PatternCreateNestedManyWithoutUserInput = {
    create?: XOR<PatternCreateWithoutUserInput, PatternUncheckedCreateWithoutUserInput> | PatternCreateWithoutUserInput[] | PatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatternCreateOrConnectWithoutUserInput | PatternCreateOrConnectWithoutUserInput[]
    createMany?: PatternCreateManyUserInputEnvelope
    connect?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
  }

  export type InsightCreateNestedManyWithoutUserInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type InterpretationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InterpretationCreateWithoutUserInput, InterpretationUncheckedCreateWithoutUserInput> | InterpretationCreateWithoutUserInput[] | InterpretationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterpretationCreateOrConnectWithoutUserInput | InterpretationCreateOrConnectWithoutUserInput[]
    createMany?: InterpretationCreateManyUserInputEnvelope
    connect?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
  }

  export type PatternUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PatternCreateWithoutUserInput, PatternUncheckedCreateWithoutUserInput> | PatternCreateWithoutUserInput[] | PatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatternCreateOrConnectWithoutUserInput | PatternCreateOrConnectWithoutUserInput[]
    createMany?: PatternCreateManyUserInputEnvelope
    connect?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
  }

  export type InsightUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EventUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type InterpretationUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterpretationCreateWithoutUserInput, InterpretationUncheckedCreateWithoutUserInput> | InterpretationCreateWithoutUserInput[] | InterpretationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterpretationCreateOrConnectWithoutUserInput | InterpretationCreateOrConnectWithoutUserInput[]
    upsert?: InterpretationUpsertWithWhereUniqueWithoutUserInput | InterpretationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterpretationCreateManyUserInputEnvelope
    set?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    disconnect?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    delete?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    connect?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    update?: InterpretationUpdateWithWhereUniqueWithoutUserInput | InterpretationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterpretationUpdateManyWithWhereWithoutUserInput | InterpretationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterpretationScalarWhereInput | InterpretationScalarWhereInput[]
  }

  export type PatternUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatternCreateWithoutUserInput, PatternUncheckedCreateWithoutUserInput> | PatternCreateWithoutUserInput[] | PatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatternCreateOrConnectWithoutUserInput | PatternCreateOrConnectWithoutUserInput[]
    upsert?: PatternUpsertWithWhereUniqueWithoutUserInput | PatternUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatternCreateManyUserInputEnvelope
    set?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    disconnect?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    delete?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    connect?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    update?: PatternUpdateWithWhereUniqueWithoutUserInput | PatternUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatternUpdateManyWithWhereWithoutUserInput | PatternUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatternScalarWhereInput | PatternScalarWhereInput[]
  }

  export type InsightUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    upsert?: InsightUpsertWithWhereUniqueWithoutUserInput | InsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    set?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    disconnect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    delete?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    update?: InsightUpdateWithWhereUniqueWithoutUserInput | InsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsightUpdateManyWithWhereWithoutUserInput | InsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsightScalarWhereInput | InsightScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type InterpretationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterpretationCreateWithoutUserInput, InterpretationUncheckedCreateWithoutUserInput> | InterpretationCreateWithoutUserInput[] | InterpretationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterpretationCreateOrConnectWithoutUserInput | InterpretationCreateOrConnectWithoutUserInput[]
    upsert?: InterpretationUpsertWithWhereUniqueWithoutUserInput | InterpretationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterpretationCreateManyUserInputEnvelope
    set?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    disconnect?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    delete?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    connect?: InterpretationWhereUniqueInput | InterpretationWhereUniqueInput[]
    update?: InterpretationUpdateWithWhereUniqueWithoutUserInput | InterpretationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterpretationUpdateManyWithWhereWithoutUserInput | InterpretationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterpretationScalarWhereInput | InterpretationScalarWhereInput[]
  }

  export type PatternUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatternCreateWithoutUserInput, PatternUncheckedCreateWithoutUserInput> | PatternCreateWithoutUserInput[] | PatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatternCreateOrConnectWithoutUserInput | PatternCreateOrConnectWithoutUserInput[]
    upsert?: PatternUpsertWithWhereUniqueWithoutUserInput | PatternUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatternCreateManyUserInputEnvelope
    set?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    disconnect?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    delete?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    connect?: PatternWhereUniqueInput | PatternWhereUniqueInput[]
    update?: PatternUpdateWithWhereUniqueWithoutUserInput | PatternUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatternUpdateManyWithWhereWithoutUserInput | PatternUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatternScalarWhereInput | PatternScalarWhereInput[]
  }

  export type InsightUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    upsert?: InsightUpsertWithWhereUniqueWithoutUserInput | InsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    set?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    disconnect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    delete?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    update?: InsightUpdateWithWhereUniqueWithoutUserInput | InsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsightUpdateManyWithWhereWithoutUserInput | InsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsightScalarWhereInput | InsightScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type InterpretationCreateNestedOneWithoutEventInput = {
    create?: XOR<InterpretationCreateWithoutEventInput, InterpretationUncheckedCreateWithoutEventInput>
    connectOrCreate?: InterpretationCreateOrConnectWithoutEventInput
    connect?: InterpretationWhereUniqueInput
  }

  export type PatternEventCreateNestedManyWithoutEventInput = {
    create?: XOR<PatternEventCreateWithoutEventInput, PatternEventUncheckedCreateWithoutEventInput> | PatternEventCreateWithoutEventInput[] | PatternEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutEventInput | PatternEventCreateOrConnectWithoutEventInput[]
    createMany?: PatternEventCreateManyEventInputEnvelope
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
  }

  export type InsightEventCreateNestedManyWithoutEventInput = {
    create?: XOR<InsightEventCreateWithoutEventInput, InsightEventUncheckedCreateWithoutEventInput> | InsightEventCreateWithoutEventInput[] | InsightEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutEventInput | InsightEventCreateOrConnectWithoutEventInput[]
    createMany?: InsightEventCreateManyEventInputEnvelope
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
  }

  export type InterpretationUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<InterpretationCreateWithoutEventInput, InterpretationUncheckedCreateWithoutEventInput>
    connectOrCreate?: InterpretationCreateOrConnectWithoutEventInput
    connect?: InterpretationWhereUniqueInput
  }

  export type PatternEventUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<PatternEventCreateWithoutEventInput, PatternEventUncheckedCreateWithoutEventInput> | PatternEventCreateWithoutEventInput[] | PatternEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutEventInput | PatternEventCreateOrConnectWithoutEventInput[]
    createMany?: PatternEventCreateManyEventInputEnvelope
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
  }

  export type InsightEventUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<InsightEventCreateWithoutEventInput, InsightEventUncheckedCreateWithoutEventInput> | InsightEventCreateWithoutEventInput[] | InsightEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutEventInput | InsightEventCreateOrConnectWithoutEventInput[]
    createMany?: InsightEventCreateManyEventInputEnvelope
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type InterpretationUpdateOneWithoutEventNestedInput = {
    create?: XOR<InterpretationCreateWithoutEventInput, InterpretationUncheckedCreateWithoutEventInput>
    connectOrCreate?: InterpretationCreateOrConnectWithoutEventInput
    upsert?: InterpretationUpsertWithoutEventInput
    disconnect?: InterpretationWhereInput | boolean
    delete?: InterpretationWhereInput | boolean
    connect?: InterpretationWhereUniqueInput
    update?: XOR<XOR<InterpretationUpdateToOneWithWhereWithoutEventInput, InterpretationUpdateWithoutEventInput>, InterpretationUncheckedUpdateWithoutEventInput>
  }

  export type PatternEventUpdateManyWithoutEventNestedInput = {
    create?: XOR<PatternEventCreateWithoutEventInput, PatternEventUncheckedCreateWithoutEventInput> | PatternEventCreateWithoutEventInput[] | PatternEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutEventInput | PatternEventCreateOrConnectWithoutEventInput[]
    upsert?: PatternEventUpsertWithWhereUniqueWithoutEventInput | PatternEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: PatternEventCreateManyEventInputEnvelope
    set?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    disconnect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    delete?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    update?: PatternEventUpdateWithWhereUniqueWithoutEventInput | PatternEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: PatternEventUpdateManyWithWhereWithoutEventInput | PatternEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: PatternEventScalarWhereInput | PatternEventScalarWhereInput[]
  }

  export type InsightEventUpdateManyWithoutEventNestedInput = {
    create?: XOR<InsightEventCreateWithoutEventInput, InsightEventUncheckedCreateWithoutEventInput> | InsightEventCreateWithoutEventInput[] | InsightEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutEventInput | InsightEventCreateOrConnectWithoutEventInput[]
    upsert?: InsightEventUpsertWithWhereUniqueWithoutEventInput | InsightEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: InsightEventCreateManyEventInputEnvelope
    set?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    disconnect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    delete?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    update?: InsightEventUpdateWithWhereUniqueWithoutEventInput | InsightEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: InsightEventUpdateManyWithWhereWithoutEventInput | InsightEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: InsightEventScalarWhereInput | InsightEventScalarWhereInput[]
  }

  export type InterpretationUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<InterpretationCreateWithoutEventInput, InterpretationUncheckedCreateWithoutEventInput>
    connectOrCreate?: InterpretationCreateOrConnectWithoutEventInput
    upsert?: InterpretationUpsertWithoutEventInput
    disconnect?: InterpretationWhereInput | boolean
    delete?: InterpretationWhereInput | boolean
    connect?: InterpretationWhereUniqueInput
    update?: XOR<XOR<InterpretationUpdateToOneWithWhereWithoutEventInput, InterpretationUpdateWithoutEventInput>, InterpretationUncheckedUpdateWithoutEventInput>
  }

  export type PatternEventUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<PatternEventCreateWithoutEventInput, PatternEventUncheckedCreateWithoutEventInput> | PatternEventCreateWithoutEventInput[] | PatternEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutEventInput | PatternEventCreateOrConnectWithoutEventInput[]
    upsert?: PatternEventUpsertWithWhereUniqueWithoutEventInput | PatternEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: PatternEventCreateManyEventInputEnvelope
    set?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    disconnect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    delete?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    update?: PatternEventUpdateWithWhereUniqueWithoutEventInput | PatternEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: PatternEventUpdateManyWithWhereWithoutEventInput | PatternEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: PatternEventScalarWhereInput | PatternEventScalarWhereInput[]
  }

  export type InsightEventUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<InsightEventCreateWithoutEventInput, InsightEventUncheckedCreateWithoutEventInput> | InsightEventCreateWithoutEventInput[] | InsightEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutEventInput | InsightEventCreateOrConnectWithoutEventInput[]
    upsert?: InsightEventUpsertWithWhereUniqueWithoutEventInput | InsightEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: InsightEventCreateManyEventInputEnvelope
    set?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    disconnect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    delete?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    update?: InsightEventUpdateWithWhereUniqueWithoutEventInput | InsightEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: InsightEventUpdateManyWithWhereWithoutEventInput | InsightEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: InsightEventScalarWhereInput | InsightEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInterpretationsInput = {
    create?: XOR<UserCreateWithoutInterpretationsInput, UserUncheckedCreateWithoutInterpretationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterpretationsInput
    connect?: UserWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutInterpretationInput = {
    create?: XOR<EventCreateWithoutInterpretationInput, EventUncheckedCreateWithoutInterpretationInput>
    connectOrCreate?: EventCreateOrConnectWithoutInterpretationInput
    connect?: EventWhereUniqueInput
  }

  export type InsightInterpretationCreateNestedManyWithoutInterpretationInput = {
    create?: XOR<InsightInterpretationCreateWithoutInterpretationInput, InsightInterpretationUncheckedCreateWithoutInterpretationInput> | InsightInterpretationCreateWithoutInterpretationInput[] | InsightInterpretationUncheckedCreateWithoutInterpretationInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInterpretationInput | InsightInterpretationCreateOrConnectWithoutInterpretationInput[]
    createMany?: InsightInterpretationCreateManyInterpretationInputEnvelope
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
  }

  export type InsightInterpretationUncheckedCreateNestedManyWithoutInterpretationInput = {
    create?: XOR<InsightInterpretationCreateWithoutInterpretationInput, InsightInterpretationUncheckedCreateWithoutInterpretationInput> | InsightInterpretationCreateWithoutInterpretationInput[] | InsightInterpretationUncheckedCreateWithoutInterpretationInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInterpretationInput | InsightInterpretationCreateOrConnectWithoutInterpretationInput[]
    createMany?: InsightInterpretationCreateManyInterpretationInputEnvelope
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
  }

  export type EnumInterpretationSourceFieldUpdateOperationsInput = {
    set?: $Enums.InterpretationSource
  }

  export type UserUpdateOneRequiredWithoutInterpretationsNestedInput = {
    create?: XOR<UserCreateWithoutInterpretationsInput, UserUncheckedCreateWithoutInterpretationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterpretationsInput
    upsert?: UserUpsertWithoutInterpretationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterpretationsInput, UserUpdateWithoutInterpretationsInput>, UserUncheckedUpdateWithoutInterpretationsInput>
  }

  export type EventUpdateOneRequiredWithoutInterpretationNestedInput = {
    create?: XOR<EventCreateWithoutInterpretationInput, EventUncheckedCreateWithoutInterpretationInput>
    connectOrCreate?: EventCreateOrConnectWithoutInterpretationInput
    upsert?: EventUpsertWithoutInterpretationInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutInterpretationInput, EventUpdateWithoutInterpretationInput>, EventUncheckedUpdateWithoutInterpretationInput>
  }

  export type InsightInterpretationUpdateManyWithoutInterpretationNestedInput = {
    create?: XOR<InsightInterpretationCreateWithoutInterpretationInput, InsightInterpretationUncheckedCreateWithoutInterpretationInput> | InsightInterpretationCreateWithoutInterpretationInput[] | InsightInterpretationUncheckedCreateWithoutInterpretationInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInterpretationInput | InsightInterpretationCreateOrConnectWithoutInterpretationInput[]
    upsert?: InsightInterpretationUpsertWithWhereUniqueWithoutInterpretationInput | InsightInterpretationUpsertWithWhereUniqueWithoutInterpretationInput[]
    createMany?: InsightInterpretationCreateManyInterpretationInputEnvelope
    set?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    disconnect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    delete?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    update?: InsightInterpretationUpdateWithWhereUniqueWithoutInterpretationInput | InsightInterpretationUpdateWithWhereUniqueWithoutInterpretationInput[]
    updateMany?: InsightInterpretationUpdateManyWithWhereWithoutInterpretationInput | InsightInterpretationUpdateManyWithWhereWithoutInterpretationInput[]
    deleteMany?: InsightInterpretationScalarWhereInput | InsightInterpretationScalarWhereInput[]
  }

  export type InsightInterpretationUncheckedUpdateManyWithoutInterpretationNestedInput = {
    create?: XOR<InsightInterpretationCreateWithoutInterpretationInput, InsightInterpretationUncheckedCreateWithoutInterpretationInput> | InsightInterpretationCreateWithoutInterpretationInput[] | InsightInterpretationUncheckedCreateWithoutInterpretationInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInterpretationInput | InsightInterpretationCreateOrConnectWithoutInterpretationInput[]
    upsert?: InsightInterpretationUpsertWithWhereUniqueWithoutInterpretationInput | InsightInterpretationUpsertWithWhereUniqueWithoutInterpretationInput[]
    createMany?: InsightInterpretationCreateManyInterpretationInputEnvelope
    set?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    disconnect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    delete?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    update?: InsightInterpretationUpdateWithWhereUniqueWithoutInterpretationInput | InsightInterpretationUpdateWithWhereUniqueWithoutInterpretationInput[]
    updateMany?: InsightInterpretationUpdateManyWithWhereWithoutInterpretationInput | InsightInterpretationUpdateManyWithWhereWithoutInterpretationInput[]
    deleteMany?: InsightInterpretationScalarWhereInput | InsightInterpretationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPatternsInput = {
    create?: XOR<UserCreateWithoutPatternsInput, UserUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatternsInput
    connect?: UserWhereUniqueInput
  }

  export type PatternEventCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternEventCreateWithoutPatternInput, PatternEventUncheckedCreateWithoutPatternInput> | PatternEventCreateWithoutPatternInput[] | PatternEventUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutPatternInput | PatternEventCreateOrConnectWithoutPatternInput[]
    createMany?: PatternEventCreateManyPatternInputEnvelope
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
  }

  export type InsightPatternCreateNestedManyWithoutPatternInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type PatternEventUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternEventCreateWithoutPatternInput, PatternEventUncheckedCreateWithoutPatternInput> | PatternEventCreateWithoutPatternInput[] | PatternEventUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutPatternInput | PatternEventCreateOrConnectWithoutPatternInput[]
    createMany?: PatternEventCreateManyPatternInputEnvelope
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
  }

  export type InsightPatternUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type EnumPatternStatusFieldUpdateOperationsInput = {
    set?: $Enums.PatternStatus
  }

  export type UserUpdateOneRequiredWithoutPatternsNestedInput = {
    create?: XOR<UserCreateWithoutPatternsInput, UserUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatternsInput
    upsert?: UserUpsertWithoutPatternsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatternsInput, UserUpdateWithoutPatternsInput>, UserUncheckedUpdateWithoutPatternsInput>
  }

  export type PatternEventUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternEventCreateWithoutPatternInput, PatternEventUncheckedCreateWithoutPatternInput> | PatternEventCreateWithoutPatternInput[] | PatternEventUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutPatternInput | PatternEventCreateOrConnectWithoutPatternInput[]
    upsert?: PatternEventUpsertWithWhereUniqueWithoutPatternInput | PatternEventUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternEventCreateManyPatternInputEnvelope
    set?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    disconnect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    delete?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    update?: PatternEventUpdateWithWhereUniqueWithoutPatternInput | PatternEventUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternEventUpdateManyWithWhereWithoutPatternInput | PatternEventUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternEventScalarWhereInput | PatternEventScalarWhereInput[]
  }

  export type InsightPatternUpdateManyWithoutPatternNestedInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutPatternInput | InsightPatternUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutPatternInput | InsightPatternUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutPatternInput | InsightPatternUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type PatternEventUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternEventCreateWithoutPatternInput, PatternEventUncheckedCreateWithoutPatternInput> | PatternEventCreateWithoutPatternInput[] | PatternEventUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternEventCreateOrConnectWithoutPatternInput | PatternEventCreateOrConnectWithoutPatternInput[]
    upsert?: PatternEventUpsertWithWhereUniqueWithoutPatternInput | PatternEventUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternEventCreateManyPatternInputEnvelope
    set?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    disconnect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    delete?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    connect?: PatternEventWhereUniqueInput | PatternEventWhereUniqueInput[]
    update?: PatternEventUpdateWithWhereUniqueWithoutPatternInput | PatternEventUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternEventUpdateManyWithWhereWithoutPatternInput | PatternEventUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternEventScalarWhereInput | PatternEventScalarWhereInput[]
  }

  export type InsightPatternUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutPatternInput | InsightPatternUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutPatternInput | InsightPatternUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutPatternInput | InsightPatternUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type PatternCreateNestedOneWithoutPatternEventsInput = {
    create?: XOR<PatternCreateWithoutPatternEventsInput, PatternUncheckedCreateWithoutPatternEventsInput>
    connectOrCreate?: PatternCreateOrConnectWithoutPatternEventsInput
    connect?: PatternWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutPatternEventsInput = {
    create?: XOR<EventCreateWithoutPatternEventsInput, EventUncheckedCreateWithoutPatternEventsInput>
    connectOrCreate?: EventCreateOrConnectWithoutPatternEventsInput
    connect?: EventWhereUniqueInput
  }

  export type PatternUpdateOneRequiredWithoutPatternEventsNestedInput = {
    create?: XOR<PatternCreateWithoutPatternEventsInput, PatternUncheckedCreateWithoutPatternEventsInput>
    connectOrCreate?: PatternCreateOrConnectWithoutPatternEventsInput
    upsert?: PatternUpsertWithoutPatternEventsInput
    connect?: PatternWhereUniqueInput
    update?: XOR<XOR<PatternUpdateToOneWithWhereWithoutPatternEventsInput, PatternUpdateWithoutPatternEventsInput>, PatternUncheckedUpdateWithoutPatternEventsInput>
  }

  export type EventUpdateOneRequiredWithoutPatternEventsNestedInput = {
    create?: XOR<EventCreateWithoutPatternEventsInput, EventUncheckedCreateWithoutPatternEventsInput>
    connectOrCreate?: EventCreateOrConnectWithoutPatternEventsInput
    upsert?: EventUpsertWithoutPatternEventsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutPatternEventsInput, EventUpdateWithoutPatternEventsInput>, EventUncheckedUpdateWithoutPatternEventsInput>
  }

  export type UserCreateNestedOneWithoutInsightsInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    connect?: UserWhereUniqueInput
  }

  export type InsightEventCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightEventCreateWithoutInsightInput, InsightEventUncheckedCreateWithoutInsightInput> | InsightEventCreateWithoutInsightInput[] | InsightEventUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutInsightInput | InsightEventCreateOrConnectWithoutInsightInput[]
    createMany?: InsightEventCreateManyInsightInputEnvelope
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
  }

  export type InsightPatternCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type InsightInterpretationCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightInterpretationCreateWithoutInsightInput, InsightInterpretationUncheckedCreateWithoutInsightInput> | InsightInterpretationCreateWithoutInsightInput[] | InsightInterpretationUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInsightInput | InsightInterpretationCreateOrConnectWithoutInsightInput[]
    createMany?: InsightInterpretationCreateManyInsightInputEnvelope
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
  }

  export type InsightEventUncheckedCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightEventCreateWithoutInsightInput, InsightEventUncheckedCreateWithoutInsightInput> | InsightEventCreateWithoutInsightInput[] | InsightEventUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutInsightInput | InsightEventCreateOrConnectWithoutInsightInput[]
    createMany?: InsightEventCreateManyInsightInputEnvelope
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
  }

  export type InsightPatternUncheckedCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type InsightInterpretationUncheckedCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightInterpretationCreateWithoutInsightInput, InsightInterpretationUncheckedCreateWithoutInsightInput> | InsightInterpretationCreateWithoutInsightInput[] | InsightInterpretationUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInsightInput | InsightInterpretationCreateOrConnectWithoutInsightInput[]
    createMany?: InsightInterpretationCreateManyInsightInputEnvelope
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
  }

  export type EnumConfidenceLevelFieldUpdateOperationsInput = {
    set?: $Enums.ConfidenceLevel
  }

  export type EnumInsightStatusFieldUpdateOperationsInput = {
    set?: $Enums.InsightStatus
  }

  export type UserUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    upsert?: UserUpsertWithoutInsightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsightsInput, UserUpdateWithoutInsightsInput>, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type InsightEventUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightEventCreateWithoutInsightInput, InsightEventUncheckedCreateWithoutInsightInput> | InsightEventCreateWithoutInsightInput[] | InsightEventUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutInsightInput | InsightEventCreateOrConnectWithoutInsightInput[]
    upsert?: InsightEventUpsertWithWhereUniqueWithoutInsightInput | InsightEventUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightEventCreateManyInsightInputEnvelope
    set?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    disconnect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    delete?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    update?: InsightEventUpdateWithWhereUniqueWithoutInsightInput | InsightEventUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightEventUpdateManyWithWhereWithoutInsightInput | InsightEventUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightEventScalarWhereInput | InsightEventScalarWhereInput[]
  }

  export type InsightPatternUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutInsightInput | InsightPatternUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutInsightInput | InsightPatternUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutInsightInput | InsightPatternUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type InsightInterpretationUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightInterpretationCreateWithoutInsightInput, InsightInterpretationUncheckedCreateWithoutInsightInput> | InsightInterpretationCreateWithoutInsightInput[] | InsightInterpretationUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInsightInput | InsightInterpretationCreateOrConnectWithoutInsightInput[]
    upsert?: InsightInterpretationUpsertWithWhereUniqueWithoutInsightInput | InsightInterpretationUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightInterpretationCreateManyInsightInputEnvelope
    set?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    disconnect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    delete?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    update?: InsightInterpretationUpdateWithWhereUniqueWithoutInsightInput | InsightInterpretationUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightInterpretationUpdateManyWithWhereWithoutInsightInput | InsightInterpretationUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightInterpretationScalarWhereInput | InsightInterpretationScalarWhereInput[]
  }

  export type InsightEventUncheckedUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightEventCreateWithoutInsightInput, InsightEventUncheckedCreateWithoutInsightInput> | InsightEventCreateWithoutInsightInput[] | InsightEventUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightEventCreateOrConnectWithoutInsightInput | InsightEventCreateOrConnectWithoutInsightInput[]
    upsert?: InsightEventUpsertWithWhereUniqueWithoutInsightInput | InsightEventUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightEventCreateManyInsightInputEnvelope
    set?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    disconnect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    delete?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    connect?: InsightEventWhereUniqueInput | InsightEventWhereUniqueInput[]
    update?: InsightEventUpdateWithWhereUniqueWithoutInsightInput | InsightEventUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightEventUpdateManyWithWhereWithoutInsightInput | InsightEventUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightEventScalarWhereInput | InsightEventScalarWhereInput[]
  }

  export type InsightPatternUncheckedUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutInsightInput | InsightPatternUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutInsightInput | InsightPatternUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutInsightInput | InsightPatternUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type InsightInterpretationUncheckedUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightInterpretationCreateWithoutInsightInput, InsightInterpretationUncheckedCreateWithoutInsightInput> | InsightInterpretationCreateWithoutInsightInput[] | InsightInterpretationUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightInterpretationCreateOrConnectWithoutInsightInput | InsightInterpretationCreateOrConnectWithoutInsightInput[]
    upsert?: InsightInterpretationUpsertWithWhereUniqueWithoutInsightInput | InsightInterpretationUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightInterpretationCreateManyInsightInputEnvelope
    set?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    disconnect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    delete?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    connect?: InsightInterpretationWhereUniqueInput | InsightInterpretationWhereUniqueInput[]
    update?: InsightInterpretationUpdateWithWhereUniqueWithoutInsightInput | InsightInterpretationUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightInterpretationUpdateManyWithWhereWithoutInsightInput | InsightInterpretationUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightInterpretationScalarWhereInput | InsightInterpretationScalarWhereInput[]
  }

  export type InsightCreateNestedOneWithoutInsightEventsInput = {
    create?: XOR<InsightCreateWithoutInsightEventsInput, InsightUncheckedCreateWithoutInsightEventsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutInsightEventsInput
    connect?: InsightWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutInsightEventsInput = {
    create?: XOR<EventCreateWithoutInsightEventsInput, EventUncheckedCreateWithoutInsightEventsInput>
    connectOrCreate?: EventCreateOrConnectWithoutInsightEventsInput
    connect?: EventWhereUniqueInput
  }

  export type EnumEvidenceRelevanceFieldUpdateOperationsInput = {
    set?: $Enums.EvidenceRelevance
  }

  export type InsightUpdateOneRequiredWithoutInsightEventsNestedInput = {
    create?: XOR<InsightCreateWithoutInsightEventsInput, InsightUncheckedCreateWithoutInsightEventsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutInsightEventsInput
    upsert?: InsightUpsertWithoutInsightEventsInput
    connect?: InsightWhereUniqueInput
    update?: XOR<XOR<InsightUpdateToOneWithWhereWithoutInsightEventsInput, InsightUpdateWithoutInsightEventsInput>, InsightUncheckedUpdateWithoutInsightEventsInput>
  }

  export type EventUpdateOneRequiredWithoutInsightEventsNestedInput = {
    create?: XOR<EventCreateWithoutInsightEventsInput, EventUncheckedCreateWithoutInsightEventsInput>
    connectOrCreate?: EventCreateOrConnectWithoutInsightEventsInput
    upsert?: EventUpsertWithoutInsightEventsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutInsightEventsInput, EventUpdateWithoutInsightEventsInput>, EventUncheckedUpdateWithoutInsightEventsInput>
  }

  export type InsightCreateNestedOneWithoutInsightPatternsInput = {
    create?: XOR<InsightCreateWithoutInsightPatternsInput, InsightUncheckedCreateWithoutInsightPatternsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutInsightPatternsInput
    connect?: InsightWhereUniqueInput
  }

  export type PatternCreateNestedOneWithoutInsightPatternsInput = {
    create?: XOR<PatternCreateWithoutInsightPatternsInput, PatternUncheckedCreateWithoutInsightPatternsInput>
    connectOrCreate?: PatternCreateOrConnectWithoutInsightPatternsInput
    connect?: PatternWhereUniqueInput
  }

  export type InsightUpdateOneRequiredWithoutInsightPatternsNestedInput = {
    create?: XOR<InsightCreateWithoutInsightPatternsInput, InsightUncheckedCreateWithoutInsightPatternsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutInsightPatternsInput
    upsert?: InsightUpsertWithoutInsightPatternsInput
    connect?: InsightWhereUniqueInput
    update?: XOR<XOR<InsightUpdateToOneWithWhereWithoutInsightPatternsInput, InsightUpdateWithoutInsightPatternsInput>, InsightUncheckedUpdateWithoutInsightPatternsInput>
  }

  export type PatternUpdateOneRequiredWithoutInsightPatternsNestedInput = {
    create?: XOR<PatternCreateWithoutInsightPatternsInput, PatternUncheckedCreateWithoutInsightPatternsInput>
    connectOrCreate?: PatternCreateOrConnectWithoutInsightPatternsInput
    upsert?: PatternUpsertWithoutInsightPatternsInput
    connect?: PatternWhereUniqueInput
    update?: XOR<XOR<PatternUpdateToOneWithWhereWithoutInsightPatternsInput, PatternUpdateWithoutInsightPatternsInput>, PatternUncheckedUpdateWithoutInsightPatternsInput>
  }

  export type InsightCreateNestedOneWithoutInsightInterpretationsInput = {
    create?: XOR<InsightCreateWithoutInsightInterpretationsInput, InsightUncheckedCreateWithoutInsightInterpretationsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutInsightInterpretationsInput
    connect?: InsightWhereUniqueInput
  }

  export type InterpretationCreateNestedOneWithoutInsightInterpretationsInput = {
    create?: XOR<InterpretationCreateWithoutInsightInterpretationsInput, InterpretationUncheckedCreateWithoutInsightInterpretationsInput>
    connectOrCreate?: InterpretationCreateOrConnectWithoutInsightInterpretationsInput
    connect?: InterpretationWhereUniqueInput
  }

  export type InsightUpdateOneRequiredWithoutInsightInterpretationsNestedInput = {
    create?: XOR<InsightCreateWithoutInsightInterpretationsInput, InsightUncheckedCreateWithoutInsightInterpretationsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutInsightInterpretationsInput
    upsert?: InsightUpsertWithoutInsightInterpretationsInput
    connect?: InsightWhereUniqueInput
    update?: XOR<XOR<InsightUpdateToOneWithWhereWithoutInsightInterpretationsInput, InsightUpdateWithoutInsightInterpretationsInput>, InsightUncheckedUpdateWithoutInsightInterpretationsInput>
  }

  export type InterpretationUpdateOneRequiredWithoutInsightInterpretationsNestedInput = {
    create?: XOR<InterpretationCreateWithoutInsightInterpretationsInput, InterpretationUncheckedCreateWithoutInsightInterpretationsInput>
    connectOrCreate?: InterpretationCreateOrConnectWithoutInsightInterpretationsInput
    upsert?: InterpretationUpsertWithoutInsightInterpretationsInput
    connect?: InterpretationWhereUniqueInput
    update?: XOR<XOR<InterpretationUpdateToOneWithWhereWithoutInsightInterpretationsInput, InterpretationUpdateWithoutInsightInterpretationsInput>, InterpretationUncheckedUpdateWithoutInsightInterpretationsInput>
  }

  export type ReviewCreateeventIdsInput = {
    set: string[]
  }

  export type ReviewCreateinterpretationIdsInput = {
    set: string[]
  }

  export type ReviewCreatepatternIdsInput = {
    set: string[]
  }

  export type ReviewCreateinsightIdsInput = {
    set: string[]
  }

  export type ReviewCreatepriorReviewIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReviewTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReviewType
  }

  export type ReviewUpdateeventIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReviewUpdateinterpretationIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReviewUpdatepatternIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReviewUpdateinsightIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReviewUpdatepriorReviewIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumInterpretationSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.InterpretationSource | EnumInterpretationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInterpretationSourceFilter<$PrismaModel> | $Enums.InterpretationSource
  }

  export type NestedEnumInterpretationSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterpretationSource | EnumInterpretationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterpretationSource[] | ListEnumInterpretationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInterpretationSourceWithAggregatesFilter<$PrismaModel> | $Enums.InterpretationSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterpretationSourceFilter<$PrismaModel>
    _max?: NestedEnumInterpretationSourceFilter<$PrismaModel>
  }

  export type NestedEnumPatternStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusFilter<$PrismaModel> | $Enums.PatternStatus
  }

  export type NestedEnumPatternStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternStatus | EnumPatternStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternStatus[] | ListEnumPatternStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternStatusWithAggregatesFilter<$PrismaModel> | $Enums.PatternStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatternStatusFilter<$PrismaModel>
    _max?: NestedEnumPatternStatusFilter<$PrismaModel>
  }

  export type NestedEnumConfidenceLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfidenceLevel | EnumConfidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceLevelFilter<$PrismaModel> | $Enums.ConfidenceLevel
  }

  export type NestedEnumInsightStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusFilter<$PrismaModel> | $Enums.InsightStatus
  }

  export type NestedEnumConfidenceLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfidenceLevel | EnumConfidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfidenceLevel[] | ListEnumConfidenceLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumConfidenceLevelWithAggregatesFilter<$PrismaModel> | $Enums.ConfidenceLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfidenceLevelFilter<$PrismaModel>
    _max?: NestedEnumConfidenceLevelFilter<$PrismaModel>
  }

  export type NestedEnumInsightStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsightStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightStatusFilter<$PrismaModel>
    _max?: NestedEnumInsightStatusFilter<$PrismaModel>
  }

  export type NestedEnumEvidenceRelevanceFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceRelevance | EnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceRelevanceFilter<$PrismaModel> | $Enums.EvidenceRelevance
  }

  export type NestedEnumEvidenceRelevanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceRelevance | EnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceRelevance[] | ListEnumEvidenceRelevanceFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceRelevanceWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceRelevance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceRelevanceFilter<$PrismaModel>
    _max?: NestedEnumEvidenceRelevanceFilter<$PrismaModel>
  }

  export type NestedEnumReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeFilter<$PrismaModel> | $Enums.ReviewType
  }

  export type NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EventCreateWithoutUserInput = {
    id?: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    interpretation?: InterpretationCreateNestedOneWithoutEventInput
    patternEvents?: PatternEventCreateNestedManyWithoutEventInput
    insightEvents?: InsightEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    interpretation?: InterpretationUncheckedCreateNestedOneWithoutEventInput
    patternEvents?: PatternEventUncheckedCreateNestedManyWithoutEventInput
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutUserInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventCreateManyUserInputEnvelope = {
    data: EventCreateManyUserInput | EventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterpretationCreateWithoutUserInput = {
    id?: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutInterpretationInput
    insightInterpretations?: InsightInterpretationCreateNestedManyWithoutInterpretationInput
  }

  export type InterpretationUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
    insightInterpretations?: InsightInterpretationUncheckedCreateNestedManyWithoutInterpretationInput
  }

  export type InterpretationCreateOrConnectWithoutUserInput = {
    where: InterpretationWhereUniqueInput
    create: XOR<InterpretationCreateWithoutUserInput, InterpretationUncheckedCreateWithoutUserInput>
  }

  export type InterpretationCreateManyUserInputEnvelope = {
    data: InterpretationCreateManyUserInput | InterpretationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatternCreateWithoutUserInput = {
    id?: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    patternEvents?: PatternEventCreateNestedManyWithoutPatternInput
    insightPatterns?: InsightPatternCreateNestedManyWithoutPatternInput
  }

  export type PatternUncheckedCreateWithoutUserInput = {
    id?: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    patternEvents?: PatternEventUncheckedCreateNestedManyWithoutPatternInput
    insightPatterns?: InsightPatternUncheckedCreateNestedManyWithoutPatternInput
  }

  export type PatternCreateOrConnectWithoutUserInput = {
    where: PatternWhereUniqueInput
    create: XOR<PatternCreateWithoutUserInput, PatternUncheckedCreateWithoutUserInput>
  }

  export type PatternCreateManyUserInputEnvelope = {
    data: PatternCreateManyUserInput | PatternCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InsightCreateWithoutUserInput = {
    id?: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    insightEvents?: InsightEventCreateNestedManyWithoutInsightInput
    insightPatterns?: InsightPatternCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutUserInput = {
    id?: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutInsightInput
    insightPatterns?: InsightPatternUncheckedCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutUserInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput>
  }

  export type InsightCreateManyUserInputEnvelope = {
    data: InsightCreateManyUserInput | InsightCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReviewType
    periodKey: string
    periodStart: Date | string
    periodEnd: Date | string
    structuredContent: JsonNullValueInput | InputJsonValue
    renderedMarkdown: string
    summary: string
    eventIds?: ReviewCreateeventIdsInput | string[]
    interpretationIds?: ReviewCreateinterpretationIdsInput | string[]
    patternIds?: ReviewCreatepatternIdsInput | string[]
    insightIds?: ReviewCreateinsightIdsInput | string[]
    priorReviewIds?: ReviewCreatepriorReviewIdsInput | string[]
    createdAt?: Date | string
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReviewType
    periodKey: string
    periodStart: Date | string
    periodEnd: Date | string
    structuredContent: JsonNullValueInput | InputJsonValue
    renderedMarkdown: string
    summary: string
    eventIds?: ReviewCreateeventIdsInput | string[]
    interpretationIds?: ReviewCreateinterpretationIdsInput | string[]
    patternIds?: ReviewCreatepatternIdsInput | string[]
    insightIds?: ReviewCreateinsightIdsInput | string[]
    priorReviewIds?: ReviewCreatepriorReviewIdsInput | string[]
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
  }

  export type EventUpdateManyWithWhereWithoutUserInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUserInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    userId?: StringFilter<"Event"> | string
    content?: StringFilter<"Event"> | string
    audioRef?: StringNullableFilter<"Event"> | string | null
    occurredAt?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type InterpretationUpsertWithWhereUniqueWithoutUserInput = {
    where: InterpretationWhereUniqueInput
    update: XOR<InterpretationUpdateWithoutUserInput, InterpretationUncheckedUpdateWithoutUserInput>
    create: XOR<InterpretationCreateWithoutUserInput, InterpretationUncheckedCreateWithoutUserInput>
  }

  export type InterpretationUpdateWithWhereUniqueWithoutUserInput = {
    where: InterpretationWhereUniqueInput
    data: XOR<InterpretationUpdateWithoutUserInput, InterpretationUncheckedUpdateWithoutUserInput>
  }

  export type InterpretationUpdateManyWithWhereWithoutUserInput = {
    where: InterpretationScalarWhereInput
    data: XOR<InterpretationUpdateManyMutationInput, InterpretationUncheckedUpdateManyWithoutUserInput>
  }

  export type InterpretationScalarWhereInput = {
    AND?: InterpretationScalarWhereInput | InterpretationScalarWhereInput[]
    OR?: InterpretationScalarWhereInput[]
    NOT?: InterpretationScalarWhereInput | InterpretationScalarWhereInput[]
    id?: StringFilter<"Interpretation"> | string
    userId?: StringFilter<"Interpretation"> | string
    eventId?: StringFilter<"Interpretation"> | string
    content?: StringFilter<"Interpretation"> | string
    source?: EnumInterpretationSourceFilter<"Interpretation"> | $Enums.InterpretationSource
    createdAt?: DateTimeFilter<"Interpretation"> | Date | string
  }

  export type PatternUpsertWithWhereUniqueWithoutUserInput = {
    where: PatternWhereUniqueInput
    update: XOR<PatternUpdateWithoutUserInput, PatternUncheckedUpdateWithoutUserInput>
    create: XOR<PatternCreateWithoutUserInput, PatternUncheckedCreateWithoutUserInput>
  }

  export type PatternUpdateWithWhereUniqueWithoutUserInput = {
    where: PatternWhereUniqueInput
    data: XOR<PatternUpdateWithoutUserInput, PatternUncheckedUpdateWithoutUserInput>
  }

  export type PatternUpdateManyWithWhereWithoutUserInput = {
    where: PatternScalarWhereInput
    data: XOR<PatternUpdateManyMutationInput, PatternUncheckedUpdateManyWithoutUserInput>
  }

  export type PatternScalarWhereInput = {
    AND?: PatternScalarWhereInput | PatternScalarWhereInput[]
    OR?: PatternScalarWhereInput[]
    NOT?: PatternScalarWhereInput | PatternScalarWhereInput[]
    id?: StringFilter<"Pattern"> | string
    userId?: StringFilter<"Pattern"> | string
    description?: StringFilter<"Pattern"> | string
    firstDetectedAt?: DateTimeFilter<"Pattern"> | Date | string
    lastReinforcedAt?: DateTimeFilter<"Pattern"> | Date | string
    status?: EnumPatternStatusFilter<"Pattern"> | $Enums.PatternStatus
    createdAt?: DateTimeFilter<"Pattern"> | Date | string
  }

  export type InsightUpsertWithWhereUniqueWithoutUserInput = {
    where: InsightWhereUniqueInput
    update: XOR<InsightUpdateWithoutUserInput, InsightUncheckedUpdateWithoutUserInput>
    create: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput>
  }

  export type InsightUpdateWithWhereUniqueWithoutUserInput = {
    where: InsightWhereUniqueInput
    data: XOR<InsightUpdateWithoutUserInput, InsightUncheckedUpdateWithoutUserInput>
  }

  export type InsightUpdateManyWithWhereWithoutUserInput = {
    where: InsightScalarWhereInput
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyWithoutUserInput>
  }

  export type InsightScalarWhereInput = {
    AND?: InsightScalarWhereInput | InsightScalarWhereInput[]
    OR?: InsightScalarWhereInput[]
    NOT?: InsightScalarWhereInput | InsightScalarWhereInput[]
    id?: StringFilter<"Insight"> | string
    userId?: StringFilter<"Insight"> | string
    statement?: StringFilter<"Insight"> | string
    explanation?: StringFilter<"Insight"> | string
    confidence?: EnumConfidenceLevelFilter<"Insight"> | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFilter<"Insight"> | $Enums.InsightStatus
    category?: StringNullableFilter<"Insight"> | string | null
    temporalScope?: StringNullableFilter<"Insight"> | string | null
    supersededById?: StringNullableFilter<"Insight"> | string | null
    supersedes?: StringNullableFilter<"Insight"> | string | null
    triggerType?: StringNullableFilter<"Insight"> | string | null
    triggerEventId?: StringNullableFilter<"Insight"> | string | null
    firstDetectedAt?: DateTimeFilter<"Insight"> | Date | string
    lastReinforcedAt?: DateTimeFilter<"Insight"> | Date | string
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    updatedAt?: DateTimeFilter<"Insight"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    type?: EnumReviewTypeFilter<"Review"> | $Enums.ReviewType
    periodKey?: StringFilter<"Review"> | string
    periodStart?: DateTimeFilter<"Review"> | Date | string
    periodEnd?: DateTimeFilter<"Review"> | Date | string
    structuredContent?: JsonFilter<"Review">
    renderedMarkdown?: StringFilter<"Review"> | string
    summary?: StringFilter<"Review"> | string
    eventIds?: StringNullableListFilter<"Review">
    interpretationIds?: StringNullableListFilter<"Review">
    patternIds?: StringNullableListFilter<"Review">
    insightIds?: StringNullableListFilter<"Review">
    priorReviewIds?: StringNullableListFilter<"Review">
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type UserCreateWithoutEventsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interpretations?: InterpretationCreateNestedManyWithoutUserInput
    patterns?: PatternCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interpretations?: InterpretationUncheckedCreateNestedManyWithoutUserInput
    patterns?: PatternUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type InterpretationCreateWithoutEventInput = {
    id?: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterpretationsInput
    insightInterpretations?: InsightInterpretationCreateNestedManyWithoutInterpretationInput
  }

  export type InterpretationUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
    insightInterpretations?: InsightInterpretationUncheckedCreateNestedManyWithoutInterpretationInput
  }

  export type InterpretationCreateOrConnectWithoutEventInput = {
    where: InterpretationWhereUniqueInput
    create: XOR<InterpretationCreateWithoutEventInput, InterpretationUncheckedCreateWithoutEventInput>
  }

  export type PatternEventCreateWithoutEventInput = {
    id?: string
    addedAt?: Date | string
    pattern: PatternCreateNestedOneWithoutPatternEventsInput
  }

  export type PatternEventUncheckedCreateWithoutEventInput = {
    id?: string
    patternId: string
    addedAt?: Date | string
  }

  export type PatternEventCreateOrConnectWithoutEventInput = {
    where: PatternEventWhereUniqueInput
    create: XOR<PatternEventCreateWithoutEventInput, PatternEventUncheckedCreateWithoutEventInput>
  }

  export type PatternEventCreateManyEventInputEnvelope = {
    data: PatternEventCreateManyEventInput | PatternEventCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type InsightEventCreateWithoutEventInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    insight: InsightCreateNestedOneWithoutInsightEventsInput
  }

  export type InsightEventUncheckedCreateWithoutEventInput = {
    id?: string
    insightId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightEventCreateOrConnectWithoutEventInput = {
    where: InsightEventWhereUniqueInput
    create: XOR<InsightEventCreateWithoutEventInput, InsightEventUncheckedCreateWithoutEventInput>
  }

  export type InsightEventCreateManyEventInputEnvelope = {
    data: InsightEventCreateManyEventInput | InsightEventCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretations?: InterpretationUpdateManyWithoutUserNestedInput
    patterns?: PatternUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretations?: InterpretationUncheckedUpdateManyWithoutUserNestedInput
    patterns?: PatternUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InterpretationUpsertWithoutEventInput = {
    update: XOR<InterpretationUpdateWithoutEventInput, InterpretationUncheckedUpdateWithoutEventInput>
    create: XOR<InterpretationCreateWithoutEventInput, InterpretationUncheckedCreateWithoutEventInput>
    where?: InterpretationWhereInput
  }

  export type InterpretationUpdateToOneWithWhereWithoutEventInput = {
    where?: InterpretationWhereInput
    data: XOR<InterpretationUpdateWithoutEventInput, InterpretationUncheckedUpdateWithoutEventInput>
  }

  export type InterpretationUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterpretationsNestedInput
    insightInterpretations?: InsightInterpretationUpdateManyWithoutInterpretationNestedInput
  }

  export type InterpretationUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightInterpretations?: InsightInterpretationUncheckedUpdateManyWithoutInterpretationNestedInput
  }

  export type PatternEventUpsertWithWhereUniqueWithoutEventInput = {
    where: PatternEventWhereUniqueInput
    update: XOR<PatternEventUpdateWithoutEventInput, PatternEventUncheckedUpdateWithoutEventInput>
    create: XOR<PatternEventCreateWithoutEventInput, PatternEventUncheckedCreateWithoutEventInput>
  }

  export type PatternEventUpdateWithWhereUniqueWithoutEventInput = {
    where: PatternEventWhereUniqueInput
    data: XOR<PatternEventUpdateWithoutEventInput, PatternEventUncheckedUpdateWithoutEventInput>
  }

  export type PatternEventUpdateManyWithWhereWithoutEventInput = {
    where: PatternEventScalarWhereInput
    data: XOR<PatternEventUpdateManyMutationInput, PatternEventUncheckedUpdateManyWithoutEventInput>
  }

  export type PatternEventScalarWhereInput = {
    AND?: PatternEventScalarWhereInput | PatternEventScalarWhereInput[]
    OR?: PatternEventScalarWhereInput[]
    NOT?: PatternEventScalarWhereInput | PatternEventScalarWhereInput[]
    id?: StringFilter<"PatternEvent"> | string
    patternId?: StringFilter<"PatternEvent"> | string
    eventId?: StringFilter<"PatternEvent"> | string
    addedAt?: DateTimeFilter<"PatternEvent"> | Date | string
  }

  export type InsightEventUpsertWithWhereUniqueWithoutEventInput = {
    where: InsightEventWhereUniqueInput
    update: XOR<InsightEventUpdateWithoutEventInput, InsightEventUncheckedUpdateWithoutEventInput>
    create: XOR<InsightEventCreateWithoutEventInput, InsightEventUncheckedCreateWithoutEventInput>
  }

  export type InsightEventUpdateWithWhereUniqueWithoutEventInput = {
    where: InsightEventWhereUniqueInput
    data: XOR<InsightEventUpdateWithoutEventInput, InsightEventUncheckedUpdateWithoutEventInput>
  }

  export type InsightEventUpdateManyWithWhereWithoutEventInput = {
    where: InsightEventScalarWhereInput
    data: XOR<InsightEventUpdateManyMutationInput, InsightEventUncheckedUpdateManyWithoutEventInput>
  }

  export type InsightEventScalarWhereInput = {
    AND?: InsightEventScalarWhereInput | InsightEventScalarWhereInput[]
    OR?: InsightEventScalarWhereInput[]
    NOT?: InsightEventScalarWhereInput | InsightEventScalarWhereInput[]
    id?: StringFilter<"InsightEvent"> | string
    insightId?: StringFilter<"InsightEvent"> | string
    eventId?: StringFilter<"InsightEvent"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightEvent"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightEvent"> | string | null
    addedAt?: DateTimeFilter<"InsightEvent"> | Date | string
  }

  export type UserCreateWithoutInterpretationsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutUserInput
    patterns?: PatternCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterpretationsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    patterns?: PatternUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterpretationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterpretationsInput, UserUncheckedCreateWithoutInterpretationsInput>
  }

  export type EventCreateWithoutInterpretationInput = {
    id?: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEventsInput
    patternEvents?: PatternEventCreateNestedManyWithoutEventInput
    insightEvents?: InsightEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutInterpretationInput = {
    id?: string
    userId: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    patternEvents?: PatternEventUncheckedCreateNestedManyWithoutEventInput
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutInterpretationInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutInterpretationInput, EventUncheckedCreateWithoutInterpretationInput>
  }

  export type InsightInterpretationCreateWithoutInterpretationInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    insight: InsightCreateNestedOneWithoutInsightInterpretationsInput
  }

  export type InsightInterpretationUncheckedCreateWithoutInterpretationInput = {
    id?: string
    insightId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightInterpretationCreateOrConnectWithoutInterpretationInput = {
    where: InsightInterpretationWhereUniqueInput
    create: XOR<InsightInterpretationCreateWithoutInterpretationInput, InsightInterpretationUncheckedCreateWithoutInterpretationInput>
  }

  export type InsightInterpretationCreateManyInterpretationInputEnvelope = {
    data: InsightInterpretationCreateManyInterpretationInput | InsightInterpretationCreateManyInterpretationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInterpretationsInput = {
    update: XOR<UserUpdateWithoutInterpretationsInput, UserUncheckedUpdateWithoutInterpretationsInput>
    create: XOR<UserCreateWithoutInterpretationsInput, UserUncheckedCreateWithoutInterpretationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterpretationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterpretationsInput, UserUncheckedUpdateWithoutInterpretationsInput>
  }

  export type UserUpdateWithoutInterpretationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutUserNestedInput
    patterns?: PatternUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterpretationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    patterns?: PatternUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventUpsertWithoutInterpretationInput = {
    update: XOR<EventUpdateWithoutInterpretationInput, EventUncheckedUpdateWithoutInterpretationInput>
    create: XOR<EventCreateWithoutInterpretationInput, EventUncheckedCreateWithoutInterpretationInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutInterpretationInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutInterpretationInput, EventUncheckedUpdateWithoutInterpretationInput>
  }

  export type EventUpdateWithoutInterpretationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    patternEvents?: PatternEventUpdateManyWithoutEventNestedInput
    insightEvents?: InsightEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutInterpretationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patternEvents?: PatternEventUncheckedUpdateManyWithoutEventNestedInput
    insightEvents?: InsightEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type InsightInterpretationUpsertWithWhereUniqueWithoutInterpretationInput = {
    where: InsightInterpretationWhereUniqueInput
    update: XOR<InsightInterpretationUpdateWithoutInterpretationInput, InsightInterpretationUncheckedUpdateWithoutInterpretationInput>
    create: XOR<InsightInterpretationCreateWithoutInterpretationInput, InsightInterpretationUncheckedCreateWithoutInterpretationInput>
  }

  export type InsightInterpretationUpdateWithWhereUniqueWithoutInterpretationInput = {
    where: InsightInterpretationWhereUniqueInput
    data: XOR<InsightInterpretationUpdateWithoutInterpretationInput, InsightInterpretationUncheckedUpdateWithoutInterpretationInput>
  }

  export type InsightInterpretationUpdateManyWithWhereWithoutInterpretationInput = {
    where: InsightInterpretationScalarWhereInput
    data: XOR<InsightInterpretationUpdateManyMutationInput, InsightInterpretationUncheckedUpdateManyWithoutInterpretationInput>
  }

  export type InsightInterpretationScalarWhereInput = {
    AND?: InsightInterpretationScalarWhereInput | InsightInterpretationScalarWhereInput[]
    OR?: InsightInterpretationScalarWhereInput[]
    NOT?: InsightInterpretationScalarWhereInput | InsightInterpretationScalarWhereInput[]
    id?: StringFilter<"InsightInterpretation"> | string
    insightId?: StringFilter<"InsightInterpretation"> | string
    interpretationId?: StringFilter<"InsightInterpretation"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightInterpretation"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightInterpretation"> | string | null
    addedAt?: DateTimeFilter<"InsightInterpretation"> | Date | string
  }

  export type UserCreateWithoutPatternsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutUserInput
    interpretations?: InterpretationCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatternsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    interpretations?: InterpretationUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatternsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatternsInput, UserUncheckedCreateWithoutPatternsInput>
  }

  export type PatternEventCreateWithoutPatternInput = {
    id?: string
    addedAt?: Date | string
    event: EventCreateNestedOneWithoutPatternEventsInput
  }

  export type PatternEventUncheckedCreateWithoutPatternInput = {
    id?: string
    eventId: string
    addedAt?: Date | string
  }

  export type PatternEventCreateOrConnectWithoutPatternInput = {
    where: PatternEventWhereUniqueInput
    create: XOR<PatternEventCreateWithoutPatternInput, PatternEventUncheckedCreateWithoutPatternInput>
  }

  export type PatternEventCreateManyPatternInputEnvelope = {
    data: PatternEventCreateManyPatternInput | PatternEventCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type InsightPatternCreateWithoutPatternInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    insight: InsightCreateNestedOneWithoutInsightPatternsInput
  }

  export type InsightPatternUncheckedCreateWithoutPatternInput = {
    id?: string
    insightId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightPatternCreateOrConnectWithoutPatternInput = {
    where: InsightPatternWhereUniqueInput
    create: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput>
  }

  export type InsightPatternCreateManyPatternInputEnvelope = {
    data: InsightPatternCreateManyPatternInput | InsightPatternCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPatternsInput = {
    update: XOR<UserUpdateWithoutPatternsInput, UserUncheckedUpdateWithoutPatternsInput>
    create: XOR<UserCreateWithoutPatternsInput, UserUncheckedCreateWithoutPatternsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatternsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatternsInput, UserUncheckedUpdateWithoutPatternsInput>
  }

  export type UserUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PatternEventUpsertWithWhereUniqueWithoutPatternInput = {
    where: PatternEventWhereUniqueInput
    update: XOR<PatternEventUpdateWithoutPatternInput, PatternEventUncheckedUpdateWithoutPatternInput>
    create: XOR<PatternEventCreateWithoutPatternInput, PatternEventUncheckedCreateWithoutPatternInput>
  }

  export type PatternEventUpdateWithWhereUniqueWithoutPatternInput = {
    where: PatternEventWhereUniqueInput
    data: XOR<PatternEventUpdateWithoutPatternInput, PatternEventUncheckedUpdateWithoutPatternInput>
  }

  export type PatternEventUpdateManyWithWhereWithoutPatternInput = {
    where: PatternEventScalarWhereInput
    data: XOR<PatternEventUpdateManyMutationInput, PatternEventUncheckedUpdateManyWithoutPatternInput>
  }

  export type InsightPatternUpsertWithWhereUniqueWithoutPatternInput = {
    where: InsightPatternWhereUniqueInput
    update: XOR<InsightPatternUpdateWithoutPatternInput, InsightPatternUncheckedUpdateWithoutPatternInput>
    create: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput>
  }

  export type InsightPatternUpdateWithWhereUniqueWithoutPatternInput = {
    where: InsightPatternWhereUniqueInput
    data: XOR<InsightPatternUpdateWithoutPatternInput, InsightPatternUncheckedUpdateWithoutPatternInput>
  }

  export type InsightPatternUpdateManyWithWhereWithoutPatternInput = {
    where: InsightPatternScalarWhereInput
    data: XOR<InsightPatternUpdateManyMutationInput, InsightPatternUncheckedUpdateManyWithoutPatternInput>
  }

  export type InsightPatternScalarWhereInput = {
    AND?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
    OR?: InsightPatternScalarWhereInput[]
    NOT?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
    id?: StringFilter<"InsightPattern"> | string
    insightId?: StringFilter<"InsightPattern"> | string
    patternId?: StringFilter<"InsightPattern"> | string
    relevance?: EnumEvidenceRelevanceFilter<"InsightPattern"> | $Enums.EvidenceRelevance
    excerpt?: StringNullableFilter<"InsightPattern"> | string | null
    addedAt?: DateTimeFilter<"InsightPattern"> | Date | string
  }

  export type PatternCreateWithoutPatternEventsInput = {
    id?: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPatternsInput
    insightPatterns?: InsightPatternCreateNestedManyWithoutPatternInput
  }

  export type PatternUncheckedCreateWithoutPatternEventsInput = {
    id?: string
    userId: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    insightPatterns?: InsightPatternUncheckedCreateNestedManyWithoutPatternInput
  }

  export type PatternCreateOrConnectWithoutPatternEventsInput = {
    where: PatternWhereUniqueInput
    create: XOR<PatternCreateWithoutPatternEventsInput, PatternUncheckedCreateWithoutPatternEventsInput>
  }

  export type EventCreateWithoutPatternEventsInput = {
    id?: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEventsInput
    interpretation?: InterpretationCreateNestedOneWithoutEventInput
    insightEvents?: InsightEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutPatternEventsInput = {
    id?: string
    userId: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    interpretation?: InterpretationUncheckedCreateNestedOneWithoutEventInput
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutPatternEventsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutPatternEventsInput, EventUncheckedCreateWithoutPatternEventsInput>
  }

  export type PatternUpsertWithoutPatternEventsInput = {
    update: XOR<PatternUpdateWithoutPatternEventsInput, PatternUncheckedUpdateWithoutPatternEventsInput>
    create: XOR<PatternCreateWithoutPatternEventsInput, PatternUncheckedCreateWithoutPatternEventsInput>
    where?: PatternWhereInput
  }

  export type PatternUpdateToOneWithWhereWithoutPatternEventsInput = {
    where?: PatternWhereInput
    data: XOR<PatternUpdateWithoutPatternEventsInput, PatternUncheckedUpdateWithoutPatternEventsInput>
  }

  export type PatternUpdateWithoutPatternEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatternsNestedInput
    insightPatterns?: InsightPatternUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateWithoutPatternEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightPatterns?: InsightPatternUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type EventUpsertWithoutPatternEventsInput = {
    update: XOR<EventUpdateWithoutPatternEventsInput, EventUncheckedUpdateWithoutPatternEventsInput>
    create: XOR<EventCreateWithoutPatternEventsInput, EventUncheckedCreateWithoutPatternEventsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutPatternEventsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutPatternEventsInput, EventUncheckedUpdateWithoutPatternEventsInput>
  }

  export type EventUpdateWithoutPatternEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    interpretation?: InterpretationUpdateOneWithoutEventNestedInput
    insightEvents?: InsightEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutPatternEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretation?: InterpretationUncheckedUpdateOneWithoutEventNestedInput
    insightEvents?: InsightEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserCreateWithoutInsightsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutUserInput
    interpretations?: InterpretationCreateNestedManyWithoutUserInput
    patterns?: PatternCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInsightsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    interpretations?: InterpretationUncheckedCreateNestedManyWithoutUserInput
    patterns?: PatternUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInsightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
  }

  export type InsightEventCreateWithoutInsightInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    event: EventCreateNestedOneWithoutInsightEventsInput
  }

  export type InsightEventUncheckedCreateWithoutInsightInput = {
    id?: string
    eventId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightEventCreateOrConnectWithoutInsightInput = {
    where: InsightEventWhereUniqueInput
    create: XOR<InsightEventCreateWithoutInsightInput, InsightEventUncheckedCreateWithoutInsightInput>
  }

  export type InsightEventCreateManyInsightInputEnvelope = {
    data: InsightEventCreateManyInsightInput | InsightEventCreateManyInsightInput[]
    skipDuplicates?: boolean
  }

  export type InsightPatternCreateWithoutInsightInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    pattern: PatternCreateNestedOneWithoutInsightPatternsInput
  }

  export type InsightPatternUncheckedCreateWithoutInsightInput = {
    id?: string
    patternId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightPatternCreateOrConnectWithoutInsightInput = {
    where: InsightPatternWhereUniqueInput
    create: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput>
  }

  export type InsightPatternCreateManyInsightInputEnvelope = {
    data: InsightPatternCreateManyInsightInput | InsightPatternCreateManyInsightInput[]
    skipDuplicates?: boolean
  }

  export type InsightInterpretationCreateWithoutInsightInput = {
    id?: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
    interpretation: InterpretationCreateNestedOneWithoutInsightInterpretationsInput
  }

  export type InsightInterpretationUncheckedCreateWithoutInsightInput = {
    id?: string
    interpretationId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightInterpretationCreateOrConnectWithoutInsightInput = {
    where: InsightInterpretationWhereUniqueInput
    create: XOR<InsightInterpretationCreateWithoutInsightInput, InsightInterpretationUncheckedCreateWithoutInsightInput>
  }

  export type InsightInterpretationCreateManyInsightInputEnvelope = {
    data: InsightInterpretationCreateManyInsightInput | InsightInterpretationCreateManyInsightInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInsightsInput = {
    update: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsightsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type UserUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUpdateManyWithoutUserNestedInput
    patterns?: PatternUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUncheckedUpdateManyWithoutUserNestedInput
    patterns?: PatternUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InsightEventUpsertWithWhereUniqueWithoutInsightInput = {
    where: InsightEventWhereUniqueInput
    update: XOR<InsightEventUpdateWithoutInsightInput, InsightEventUncheckedUpdateWithoutInsightInput>
    create: XOR<InsightEventCreateWithoutInsightInput, InsightEventUncheckedCreateWithoutInsightInput>
  }

  export type InsightEventUpdateWithWhereUniqueWithoutInsightInput = {
    where: InsightEventWhereUniqueInput
    data: XOR<InsightEventUpdateWithoutInsightInput, InsightEventUncheckedUpdateWithoutInsightInput>
  }

  export type InsightEventUpdateManyWithWhereWithoutInsightInput = {
    where: InsightEventScalarWhereInput
    data: XOR<InsightEventUpdateManyMutationInput, InsightEventUncheckedUpdateManyWithoutInsightInput>
  }

  export type InsightPatternUpsertWithWhereUniqueWithoutInsightInput = {
    where: InsightPatternWhereUniqueInput
    update: XOR<InsightPatternUpdateWithoutInsightInput, InsightPatternUncheckedUpdateWithoutInsightInput>
    create: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput>
  }

  export type InsightPatternUpdateWithWhereUniqueWithoutInsightInput = {
    where: InsightPatternWhereUniqueInput
    data: XOR<InsightPatternUpdateWithoutInsightInput, InsightPatternUncheckedUpdateWithoutInsightInput>
  }

  export type InsightPatternUpdateManyWithWhereWithoutInsightInput = {
    where: InsightPatternScalarWhereInput
    data: XOR<InsightPatternUpdateManyMutationInput, InsightPatternUncheckedUpdateManyWithoutInsightInput>
  }

  export type InsightInterpretationUpsertWithWhereUniqueWithoutInsightInput = {
    where: InsightInterpretationWhereUniqueInput
    update: XOR<InsightInterpretationUpdateWithoutInsightInput, InsightInterpretationUncheckedUpdateWithoutInsightInput>
    create: XOR<InsightInterpretationCreateWithoutInsightInput, InsightInterpretationUncheckedCreateWithoutInsightInput>
  }

  export type InsightInterpretationUpdateWithWhereUniqueWithoutInsightInput = {
    where: InsightInterpretationWhereUniqueInput
    data: XOR<InsightInterpretationUpdateWithoutInsightInput, InsightInterpretationUncheckedUpdateWithoutInsightInput>
  }

  export type InsightInterpretationUpdateManyWithWhereWithoutInsightInput = {
    where: InsightInterpretationScalarWhereInput
    data: XOR<InsightInterpretationUpdateManyMutationInput, InsightInterpretationUncheckedUpdateManyWithoutInsightInput>
  }

  export type InsightCreateWithoutInsightEventsInput = {
    id?: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    insightPatterns?: InsightPatternCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutInsightEventsInput = {
    id?: string
    userId: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    insightPatterns?: InsightPatternUncheckedCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutInsightEventsInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutInsightEventsInput, InsightUncheckedCreateWithoutInsightEventsInput>
  }

  export type EventCreateWithoutInsightEventsInput = {
    id?: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEventsInput
    interpretation?: InterpretationCreateNestedOneWithoutEventInput
    patternEvents?: PatternEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutInsightEventsInput = {
    id?: string
    userId: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
    interpretation?: InterpretationUncheckedCreateNestedOneWithoutEventInput
    patternEvents?: PatternEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutInsightEventsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutInsightEventsInput, EventUncheckedCreateWithoutInsightEventsInput>
  }

  export type InsightUpsertWithoutInsightEventsInput = {
    update: XOR<InsightUpdateWithoutInsightEventsInput, InsightUncheckedUpdateWithoutInsightEventsInput>
    create: XOR<InsightCreateWithoutInsightEventsInput, InsightUncheckedCreateWithoutInsightEventsInput>
    where?: InsightWhereInput
  }

  export type InsightUpdateToOneWithWhereWithoutInsightEventsInput = {
    where?: InsightWhereInput
    data: XOR<InsightUpdateWithoutInsightEventsInput, InsightUncheckedUpdateWithoutInsightEventsInput>
  }

  export type InsightUpdateWithoutInsightEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    insightPatterns?: InsightPatternUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutInsightEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightPatterns?: InsightPatternUncheckedUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type EventUpsertWithoutInsightEventsInput = {
    update: XOR<EventUpdateWithoutInsightEventsInput, EventUncheckedUpdateWithoutInsightEventsInput>
    create: XOR<EventCreateWithoutInsightEventsInput, EventUncheckedCreateWithoutInsightEventsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutInsightEventsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutInsightEventsInput, EventUncheckedUpdateWithoutInsightEventsInput>
  }

  export type EventUpdateWithoutInsightEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    interpretation?: InterpretationUpdateOneWithoutEventNestedInput
    patternEvents?: PatternEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutInsightEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretation?: InterpretationUncheckedUpdateOneWithoutEventNestedInput
    patternEvents?: PatternEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type InsightCreateWithoutInsightPatternsInput = {
    id?: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    insightEvents?: InsightEventCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutInsightPatternsInput = {
    id?: string
    userId: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutInsightInput
    insightInterpretations?: InsightInterpretationUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutInsightPatternsInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutInsightPatternsInput, InsightUncheckedCreateWithoutInsightPatternsInput>
  }

  export type PatternCreateWithoutInsightPatternsInput = {
    id?: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPatternsInput
    patternEvents?: PatternEventCreateNestedManyWithoutPatternInput
  }

  export type PatternUncheckedCreateWithoutInsightPatternsInput = {
    id?: string
    userId: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
    patternEvents?: PatternEventUncheckedCreateNestedManyWithoutPatternInput
  }

  export type PatternCreateOrConnectWithoutInsightPatternsInput = {
    where: PatternWhereUniqueInput
    create: XOR<PatternCreateWithoutInsightPatternsInput, PatternUncheckedCreateWithoutInsightPatternsInput>
  }

  export type InsightUpsertWithoutInsightPatternsInput = {
    update: XOR<InsightUpdateWithoutInsightPatternsInput, InsightUncheckedUpdateWithoutInsightPatternsInput>
    create: XOR<InsightCreateWithoutInsightPatternsInput, InsightUncheckedCreateWithoutInsightPatternsInput>
    where?: InsightWhereInput
  }

  export type InsightUpdateToOneWithWhereWithoutInsightPatternsInput = {
    where?: InsightWhereInput
    data: XOR<InsightUpdateWithoutInsightPatternsInput, InsightUncheckedUpdateWithoutInsightPatternsInput>
  }

  export type InsightUpdateWithoutInsightPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    insightEvents?: InsightEventUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutInsightPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightEvents?: InsightEventUncheckedUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type PatternUpsertWithoutInsightPatternsInput = {
    update: XOR<PatternUpdateWithoutInsightPatternsInput, PatternUncheckedUpdateWithoutInsightPatternsInput>
    create: XOR<PatternCreateWithoutInsightPatternsInput, PatternUncheckedCreateWithoutInsightPatternsInput>
    where?: PatternWhereInput
  }

  export type PatternUpdateToOneWithWhereWithoutInsightPatternsInput = {
    where?: PatternWhereInput
    data: XOR<PatternUpdateWithoutInsightPatternsInput, PatternUncheckedUpdateWithoutInsightPatternsInput>
  }

  export type PatternUpdateWithoutInsightPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatternsNestedInput
    patternEvents?: PatternEventUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateWithoutInsightPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patternEvents?: PatternEventUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type InsightCreateWithoutInsightInterpretationsInput = {
    id?: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    insightEvents?: InsightEventCreateNestedManyWithoutInsightInput
    insightPatterns?: InsightPatternCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutInsightInterpretationsInput = {
    id?: string
    userId: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    insightEvents?: InsightEventUncheckedCreateNestedManyWithoutInsightInput
    insightPatterns?: InsightPatternUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutInsightInterpretationsInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutInsightInterpretationsInput, InsightUncheckedCreateWithoutInsightInterpretationsInput>
  }

  export type InterpretationCreateWithoutInsightInterpretationsInput = {
    id?: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterpretationsInput
    event: EventCreateNestedOneWithoutInterpretationInput
  }

  export type InterpretationUncheckedCreateWithoutInsightInterpretationsInput = {
    id?: string
    userId: string
    eventId: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
  }

  export type InterpretationCreateOrConnectWithoutInsightInterpretationsInput = {
    where: InterpretationWhereUniqueInput
    create: XOR<InterpretationCreateWithoutInsightInterpretationsInput, InterpretationUncheckedCreateWithoutInsightInterpretationsInput>
  }

  export type InsightUpsertWithoutInsightInterpretationsInput = {
    update: XOR<InsightUpdateWithoutInsightInterpretationsInput, InsightUncheckedUpdateWithoutInsightInterpretationsInput>
    create: XOR<InsightCreateWithoutInsightInterpretationsInput, InsightUncheckedCreateWithoutInsightInterpretationsInput>
    where?: InsightWhereInput
  }

  export type InsightUpdateToOneWithWhereWithoutInsightInterpretationsInput = {
    where?: InsightWhereInput
    data: XOR<InsightUpdateWithoutInsightInterpretationsInput, InsightUncheckedUpdateWithoutInsightInterpretationsInput>
  }

  export type InsightUpdateWithoutInsightInterpretationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    insightEvents?: InsightEventUpdateManyWithoutInsightNestedInput
    insightPatterns?: InsightPatternUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutInsightInterpretationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightEvents?: InsightEventUncheckedUpdateManyWithoutInsightNestedInput
    insightPatterns?: InsightPatternUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type InterpretationUpsertWithoutInsightInterpretationsInput = {
    update: XOR<InterpretationUpdateWithoutInsightInterpretationsInput, InterpretationUncheckedUpdateWithoutInsightInterpretationsInput>
    create: XOR<InterpretationCreateWithoutInsightInterpretationsInput, InterpretationUncheckedCreateWithoutInsightInterpretationsInput>
    where?: InterpretationWhereInput
  }

  export type InterpretationUpdateToOneWithWhereWithoutInsightInterpretationsInput = {
    where?: InterpretationWhereInput
    data: XOR<InterpretationUpdateWithoutInsightInterpretationsInput, InterpretationUncheckedUpdateWithoutInsightInterpretationsInput>
  }

  export type InterpretationUpdateWithoutInsightInterpretationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterpretationsNestedInput
    event?: EventUpdateOneRequiredWithoutInterpretationNestedInput
  }

  export type InterpretationUncheckedUpdateWithoutInsightInterpretationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutUserInput
    interpretations?: InterpretationCreateNestedManyWithoutUserInput
    patterns?: PatternCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    name?: string | null
    timezone?: string
    baseline?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    interpretations?: InterpretationUncheckedCreateNestedManyWithoutUserInput
    patterns?: PatternUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUpdateManyWithoutUserNestedInput
    patterns?: PatternUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    baseline?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    interpretations?: InterpretationUncheckedUpdateManyWithoutUserNestedInput
    patterns?: PatternUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventCreateManyUserInput = {
    id?: string
    content: string
    audioRef?: string | null
    occurredAt: Date | string
    createdAt?: Date | string
  }

  export type InterpretationCreateManyUserInput = {
    id?: string
    eventId: string
    content: string
    source: $Enums.InterpretationSource
    createdAt?: Date | string
  }

  export type PatternCreateManyUserInput = {
    id?: string
    description: string
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    status?: $Enums.PatternStatus
    createdAt?: Date | string
  }

  export type InsightCreateManyUserInput = {
    id?: string
    statement: string
    explanation: string
    confidence?: $Enums.ConfidenceLevel
    status?: $Enums.InsightStatus
    category?: string | null
    temporalScope?: string | null
    supersededById?: string | null
    supersedes?: string | null
    triggerType?: string | null
    triggerEventId?: string | null
    firstDetectedAt?: Date | string
    lastReinforcedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    type: $Enums.ReviewType
    periodKey: string
    periodStart: Date | string
    periodEnd: Date | string
    structuredContent: JsonNullValueInput | InputJsonValue
    renderedMarkdown: string
    summary: string
    eventIds?: ReviewCreateeventIdsInput | string[]
    interpretationIds?: ReviewCreateinterpretationIdsInput | string[]
    patternIds?: ReviewCreatepatternIdsInput | string[]
    insightIds?: ReviewCreateinsightIdsInput | string[]
    priorReviewIds?: ReviewCreatepriorReviewIdsInput | string[]
    createdAt?: Date | string
  }

  export type EventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretation?: InterpretationUpdateOneWithoutEventNestedInput
    patternEvents?: PatternEventUpdateManyWithoutEventNestedInput
    insightEvents?: InsightEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretation?: InterpretationUncheckedUpdateOneWithoutEventNestedInput
    patternEvents?: PatternEventUncheckedUpdateManyWithoutEventNestedInput
    insightEvents?: InsightEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audioRef?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterpretationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutInterpretationNestedInput
    insightInterpretations?: InsightInterpretationUpdateManyWithoutInterpretationNestedInput
  }

  export type InterpretationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightInterpretations?: InsightInterpretationUncheckedUpdateManyWithoutInterpretationNestedInput
  }

  export type InterpretationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumInterpretationSourceFieldUpdateOperationsInput | $Enums.InterpretationSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patternEvents?: PatternEventUpdateManyWithoutPatternNestedInput
    insightPatterns?: InsightPatternUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patternEvents?: PatternEventUncheckedUpdateManyWithoutPatternNestedInput
    insightPatterns?: InsightPatternUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPatternStatusFieldUpdateOperationsInput | $Enums.PatternStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightEvents?: InsightEventUpdateManyWithoutInsightNestedInput
    insightPatterns?: InsightPatternUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insightEvents?: InsightEventUncheckedUpdateManyWithoutInsightNestedInput
    insightPatterns?: InsightPatternUncheckedUpdateManyWithoutInsightNestedInput
    insightInterpretations?: InsightInterpretationUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: EnumConfidenceLevelFieldUpdateOperationsInput | $Enums.ConfidenceLevel
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    temporalScope?: NullableStringFieldUpdateOperationsInput | string | null
    supersededById?: NullableStringFieldUpdateOperationsInput | string | null
    supersedes?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    triggerEventId?: NullableStringFieldUpdateOperationsInput | string | null
    firstDetectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReinforcedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    periodKey?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredContent?: JsonNullValueInput | InputJsonValue
    renderedMarkdown?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    eventIds?: ReviewUpdateeventIdsInput | string[]
    interpretationIds?: ReviewUpdateinterpretationIdsInput | string[]
    patternIds?: ReviewUpdatepatternIdsInput | string[]
    insightIds?: ReviewUpdateinsightIdsInput | string[]
    priorReviewIds?: ReviewUpdatepriorReviewIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    periodKey?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredContent?: JsonNullValueInput | InputJsonValue
    renderedMarkdown?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    eventIds?: ReviewUpdateeventIdsInput | string[]
    interpretationIds?: ReviewUpdateinterpretationIdsInput | string[]
    patternIds?: ReviewUpdatepatternIdsInput | string[]
    insightIds?: ReviewUpdateinsightIdsInput | string[]
    priorReviewIds?: ReviewUpdatepriorReviewIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    periodKey?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    structuredContent?: JsonNullValueInput | InputJsonValue
    renderedMarkdown?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    eventIds?: ReviewUpdateeventIdsInput | string[]
    interpretationIds?: ReviewUpdateinterpretationIdsInput | string[]
    patternIds?: ReviewUpdatepatternIdsInput | string[]
    insightIds?: ReviewUpdateinsightIdsInput | string[]
    priorReviewIds?: ReviewUpdatepriorReviewIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternEventCreateManyEventInput = {
    id?: string
    patternId: string
    addedAt?: Date | string
  }

  export type InsightEventCreateManyEventInput = {
    id?: string
    insightId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type PatternEventUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: PatternUpdateOneRequiredWithoutPatternEventsNestedInput
  }

  export type PatternEventUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternEventUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightEventUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutInsightEventsNestedInput
  }

  export type InsightEventUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightEventUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightInterpretationCreateManyInterpretationInput = {
    id?: string
    insightId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightInterpretationUpdateWithoutInterpretationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutInsightInterpretationsNestedInput
  }

  export type InsightInterpretationUncheckedUpdateWithoutInterpretationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightInterpretationUncheckedUpdateManyWithoutInterpretationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternEventCreateManyPatternInput = {
    id?: string
    eventId: string
    addedAt?: Date | string
  }

  export type InsightPatternCreateManyPatternInput = {
    id?: string
    insightId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type PatternEventUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutPatternEventsNestedInput
  }

  export type PatternEventUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternEventUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutInsightPatternsNestedInput
  }

  export type InsightPatternUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightEventCreateManyInsightInput = {
    id?: string
    eventId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightPatternCreateManyInsightInput = {
    id?: string
    patternId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightInterpretationCreateManyInsightInput = {
    id?: string
    interpretationId: string
    relevance?: $Enums.EvidenceRelevance
    excerpt?: string | null
    addedAt?: Date | string
  }

  export type InsightEventUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutInsightEventsNestedInput
  }

  export type InsightEventUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightEventUncheckedUpdateManyWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: PatternUpdateOneRequiredWithoutInsightPatternsNestedInput
  }

  export type InsightPatternUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternUncheckedUpdateManyWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightInterpretationUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interpretation?: InterpretationUpdateOneRequiredWithoutInsightInterpretationsNestedInput
  }

  export type InsightInterpretationUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    interpretationId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightInterpretationUncheckedUpdateManyWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    interpretationId?: StringFieldUpdateOperationsInput | string
    relevance?: EnumEvidenceRelevanceFieldUpdateOperationsInput | $Enums.EvidenceRelevance
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}